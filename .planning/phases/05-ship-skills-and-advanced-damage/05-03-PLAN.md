---
phase: 05-ship-skills-and-advanced-damage
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Assets/Scripts/ECS/Components/SkillComponents.cs
  - Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
  - Assets/Scripts/MonoBehaviours/UI/SkillBarController.cs
  - Assets/Scripts/ECS/Systems/LaserBurstSystem.cs
  - Assets/Scripts/ECS/Systems/ChainLightningSystem.cs
  - Assets/Scripts/ECS/Systems/EmpPulseSystem.cs
  - Assets/Scripts/ECS/Systems/OverchargeSystem.cs
  - Assets/Scripts/ECS/Systems/SkillCooldownSystem.cs
autonomous: true
gap_closure: true
requirements: [SKIL-07, SKIL-08, SKIL-01, SKIL-02, SKIL-03, SKIL-04, SKIL-05, SKIL-06, DMGS-01, DMGS-02, DMGS-03]

must_haves:
  truths:
    - "A SkillUnlockData ECS singleton exists tracking per-skill unlock state as 4 booleans"
    - "A SkillStatsData ECS singleton exists with runtime-mutable damage, cooldown, radius, and duration values for all 4 skills"
    - "All 4 skills default to unlocked so gameplay is not broken before Phase 6 tech tree"
    - "SkillBarController hides or disables slots for locked skills"
    - "Skill systems read damage/cooldown/radius values from SkillStatsData singleton instead of GameConstants"
    - "Phase 6 can flip skills to locked-by-default and modify SkillStatsData values without touching skill system code"
  artifacts:
    - path: "Assets/Scripts/ECS/Components/SkillComponents.cs"
      provides: "SkillUnlockData and SkillStatsData IComponentData structs"
      contains: "SkillUnlockData"
    - path: "Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs"
      provides: "Bootstrap of SkillUnlockData and SkillStatsData singletons"
      contains: "SkillUnlockData"
    - path: "Assets/Scripts/MonoBehaviours/UI/SkillBarController.cs"
      provides: "Unlock check per slot hiding locked skills"
      contains: "SkillUnlockData"
  key_links:
    - from: "Assets/Scripts/MonoBehaviours/UI/SkillBarController.cs"
      to: "SkillUnlockData singleton"
      via: "LateUpdate reads unlock state per slot to show/hide"
      pattern: "SkillUnlockData.*Unlocked"
    - from: "Assets/Scripts/ECS/Systems/LaserBurstSystem.cs"
      to: "SkillStatsData singleton"
      via: "OnUpdate reads LaserDamage from singleton instead of GameConstants"
      pattern: "SkillStatsData.*LaserDamage"
    - from: "Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs"
      to: "SkillStatsData + SkillUnlockData singletons"
      via: "Start() creates entities seeded from GameConstants defaults"
      pattern: "SkillStatsData.*SkillUnlockData"
---

<objective>
Close the two remaining Phase 5 verification gaps: add skill unlock gating scaffolding (SKIL-07) and replace compile-time skill constants with runtime-mutable ECS singletons (SKIL-08).

Purpose: SKIL-07 requires skills to be gatable by unlock state, and SKIL-08 requires skill stats to be runtime-upgradeable. Both are scaffolding for Phase 6's tech tree -- this plan builds the data layer and wiring so Phase 6 can flip defaults and modify values without touching skill system code. All skills default to UNLOCKED and current balance values are preserved.

Output: 2 new IComponentData structs (SkillUnlockData, SkillStatsData), modified ECSBootstrap, modified SkillBarController with unlock checks, and 5 modified skill systems reading from SkillStatsData instead of GameConstants.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ship-skills-and-advanced-damage/05-01-SUMMARY.md
@.planning/phases/05-ship-skills-and-advanced-damage/05-02-SUMMARY.md
@.planning/phases/05-ship-skills-and-advanced-damage/05-VERIFICATION.md

Key source files to read before implementing:
@Assets/Scripts/ECS/Components/SkillComponents.cs
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
@Assets/Scripts/MonoBehaviours/UI/SkillBarController.cs
@Assets/Scripts/ECS/Systems/LaserBurstSystem.cs
@Assets/Scripts/ECS/Systems/ChainLightningSystem.cs
@Assets/Scripts/ECS/Systems/EmpPulseSystem.cs
@Assets/Scripts/ECS/Systems/OverchargeSystem.cs
@Assets/Scripts/ECS/Systems/SkillCooldownSystem.cs
@Assets/Scripts/ECS/Systems/MiningDamageSystem.cs
@Assets/Scripts/Shared/GameConstants.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SkillUnlockData and SkillStatsData ECS singletons, bootstrap them, and wire unlock gating in SkillBarController</name>
  <files>
    Assets/Scripts/ECS/Components/SkillComponents.cs
    Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
    Assets/Scripts/MonoBehaviours/UI/SkillBarController.cs
  </files>
  <action>
**1. Add two new structs to `Assets/Scripts/ECS/Components/SkillComponents.cs`:**

Add these at the end of the namespace, after the existing `BurningData` struct:

```csharp
/// <summary>
/// Singleton: tracks which skills are unlocked.
/// Phase 6 tech tree will set these to false by default and flip to true on purchase.
/// Currently all default to true so gameplay is not broken before tech tree exists.
/// </summary>
public struct SkillUnlockData : IComponentData
{
    public bool Skill1Unlocked; // Laser Burst
    public bool Skill2Unlocked; // Chain Lightning
    public bool Skill3Unlocked; // EMP Pulse
    public bool Skill4Unlocked; // Overcharge
}

/// <summary>
/// Singleton: runtime-mutable skill stats that replace compile-time GameConstants values.
/// Phase 6 tech tree modifies these values when upgrades are purchased.
/// ECSBootstrap seeds from GameConstants defaults. Skill systems read from this singleton.
/// </summary>
public struct SkillStatsData : IComponentData
{
    // Laser Burst
    public float LaserDamage;
    public float LaserCooldown;
    public float LaserBeamHalfWidth;
    public float LaserDotDamagePerTick;
    public float LaserDotTickInterval;
    public float LaserDotDuration;

    // Chain Lightning
    public float ChainDamage;
    public float ChainCooldown;
    public int ChainMaxTargets;
    public float ChainMaxDist;

    // EMP Pulse
    public float EmpDamage;
    public float EmpCooldown;
    public float EmpRadius;
    public float EmpDotDamagePerTick;
    public float EmpDotTickInterval;
    public float EmpDotDuration;

    // Overcharge
    public float OverchargeCooldown;
    public float OverchargeDuration;
    public float OverchargeDamageMultiplier;
    public float OverchargeRadiusMultiplier;
}
```

**2. Extend `Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs`:**

After the existing SkillEvent buffer creation block, add:

```csharp
// Phase 5 gap closure: Skill unlock gating
// All skills default to UNLOCKED. Phase 6 tech tree will change defaults to false
// and flip to true on Ship branch purchases.
var skillUnlockEntity = em.CreateEntity(typeof(SkillUnlockData));
em.SetComponentData(skillUnlockEntity, new SkillUnlockData
{
    Skill1Unlocked = true,
    Skill2Unlocked = true,
    Skill3Unlocked = true,
    Skill4Unlocked = true
});

// Phase 5 gap closure: Runtime-mutable skill stats
// Seeded from GameConstants. Phase 6 tech tree will modify these at runtime.
var skillStatsEntity = em.CreateEntity(typeof(SkillStatsData));
em.SetComponentData(skillStatsEntity, new SkillStatsData
{
    LaserDamage = GameConstants.LaserBurstDamage,
    LaserCooldown = GameConstants.LaserBurstCooldown,
    LaserBeamHalfWidth = GameConstants.LaserBurstBeamHalfWidth,
    LaserDotDamagePerTick = GameConstants.LaserDotDamagePerTick,
    LaserDotTickInterval = GameConstants.LaserDotTickInterval,
    LaserDotDuration = GameConstants.LaserDotDuration,
    ChainDamage = GameConstants.ChainLightningDamage,
    ChainCooldown = GameConstants.ChainLightningCooldown,
    ChainMaxTargets = GameConstants.ChainLightningMaxTargets,
    ChainMaxDist = GameConstants.ChainLightningMaxChainDist,
    EmpDamage = GameConstants.EmpPulseDamage,
    EmpCooldown = GameConstants.EmpPulseCooldown,
    EmpRadius = GameConstants.EmpPulseRadius,
    EmpDotDamagePerTick = GameConstants.EmpDotDamagePerTick,
    EmpDotTickInterval = GameConstants.EmpDotTickInterval,
    EmpDotDuration = GameConstants.EmpDotDuration,
    OverchargeCooldown = GameConstants.OverchargeCooldown,
    OverchargeDuration = GameConstants.OverchargeDuration,
    OverchargeDamageMultiplier = GameConstants.OverchargeDamageMultiplier,
    OverchargeRadiusMultiplier = GameConstants.OverchargeRadiusMultiplier
});
```

Also update the Debug.Log string to append `, SkillUnlock, SkillStats`.

**3. Modify `Assets/Scripts/MonoBehaviours/UI/SkillBarController.cs`:**

Add unlock gating to the skill bar:

a. Add a new ECS entity field and slot root tracking:
```csharp
private Entity skillUnlockEntity;
private GameObject[] slotRoots;  // Root GO of each skill slot for show/hide
```

b. Extend the `Initialize` method signature to accept slot root GameObjects:
```csharp
public void Initialize(Image[] overlays, TextMeshProUGUI[] texts,
                       Button[] buttons, GameObject root, GameObject[] slots)
```
Store `slots` to `slotRoots`.

c. In `TryInitECS()`, after the gameStateEntity query, add:
```csharp
var unlockQuery = em.CreateEntityQuery(typeof(SkillUnlockData));
if (unlockQuery.CalculateEntityCount() == 0) return false;
skillUnlockEntity = unlockQuery.GetSingletonEntity();
```

d. In `LateUpdate()`, after reading `cooldowns`, read unlock state:
```csharp
var unlocks = em.GetComponentData<SkillUnlockData>(skillUnlockEntity);
```

e. Before calling `UpdateSlot`, check unlock state per slot. For each slot:
```csharp
bool[] unlocked = { unlocks.Skill1Unlocked, unlocks.Skill2Unlocked,
                    unlocks.Skill3Unlocked, unlocks.Skill4Unlocked };
```

Then in the per-slot update loop, toggle slot visibility:
```csharp
if (slotRoots != null && slotRoots[i] != null)
{
    if (slotRoots[i].activeSelf != unlocked[i])
        slotRoots[i].SetActive(unlocked[i]);
}
if (!unlocked[i]) continue; // skip cooldown update for locked slots
```

f. In `OnSkillButtonClicked`, add an early return if the skill is not unlocked:
```csharp
var unlockData = em.GetComponentData<SkillUnlockData>(skillUnlockEntity);
bool isUnlocked = skillIndex switch
{
    0 => unlockData.Skill1Unlocked,
    1 => unlockData.Skill2Unlocked,
    2 => unlockData.Skill3Unlocked,
    3 => unlockData.Skill4Unlocked,
    _ => false
};
if (!isUnlocked) return;
```

g. Also update `UISetup.cs` where `SkillBarController.Initialize` is called. Find the call site and pass the array of slot root GameObjects. The slots are already being created in UISetup.CreateSkillBarCanvas() -- just collect them into a `GameObject[]` and pass them. This is a minor wiring change in UISetup.
  </action>
  <verify>
Open the project in Unity Editor. Verify no compilation errors. Enter Play Mode. Confirm:
1. All 4 skill slots still visible (since all default to unlocked).
2. Skills still activate via keyboard and button click.
3. In Entity Debugger, confirm SkillUnlockData and SkillStatsData singleton entities exist.
4. SkillUnlockData shows all 4 booleans as true.
5. SkillStatsData values match GameConstants defaults.
  </verify>
  <done>
SkillUnlockData and SkillStatsData singletons created and bootstrapped. SkillBarController checks unlock state per slot and hides locked skills. All skills default to unlocked so gameplay is unchanged. UISetup passes slot roots to SkillBarController. Phase 6 can set any skill to locked by changing SkillUnlockData.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate all skill systems to read from SkillStatsData singleton instead of GameConstants</name>
  <files>
    Assets/Scripts/ECS/Systems/LaserBurstSystem.cs
    Assets/Scripts/ECS/Systems/ChainLightningSystem.cs
    Assets/Scripts/ECS/Systems/EmpPulseSystem.cs
    Assets/Scripts/ECS/Systems/OverchargeSystem.cs
    Assets/Scripts/ECS/Systems/SkillCooldownSystem.cs
  </files>
  <action>
**Migration pattern for each system:** Replace `GameConstants.XxxYyy` references with reads from the `SkillStatsData` singleton. Each system adds `state.RequireForUpdate<SkillStatsData>();` in OnCreate and reads the singleton at the top of OnUpdate.

**IMPORTANT:** Do NOT remove the GameConstants values themselves -- they remain as the seed source for ECSBootstrap and as documentation of default values. Only the runtime reads in systems change.

**IMPORTANT:** All skill systems must also add `state.RequireForUpdate<SkillUnlockData>();` and guard activation on unlock state. If the skill is not unlocked, return early (same as if not pressed). This is a defense-in-depth measure alongside the UI gating.

**1. Modify `Assets/Scripts/ECS/Systems/LaserBurstSystem.cs`:**

a. In `OnCreate`, add:
```csharp
state.RequireForUpdate<SkillStatsData>();
state.RequireForUpdate<SkillUnlockData>();
```

b. At the top of `OnUpdate`, after the Skill1Pressed check, add unlock guard:
```csharp
var unlocks = SystemAPI.GetSingleton<SkillUnlockData>();
if (!unlocks.Skill1Unlocked) return;
```

c. After the cooldown activation line, read stats:
```csharp
var stats = SystemAPI.GetSingleton<SkillStatsData>();
```

d. Replace all `GameConstants.LaserBurstDamage` with `stats.LaserDamage`.
e. Replace `GameConstants.LaserBurstBeamHalfWidth` with `stats.LaserBeamHalfWidth`.
f. Replace `GameConstants.LaserDotDamagePerTick` with `stats.LaserDotDamagePerTick`.
g. Replace `GameConstants.LaserDotTickInterval` with `stats.LaserDotTickInterval`.
h. Replace `GameConstants.LaserDotDuration` with `stats.LaserDotDuration`.

Note: `GameConstants.ShipPositionX` and `GameConstants.ShipPositionZ` remain as GameConstants -- these are position values, not skill stats.

**2. Modify `Assets/Scripts/ECS/Systems/ChainLightningSystem.cs`:**

a. In `OnCreate`, add `state.RequireForUpdate<SkillStatsData>();` and `state.RequireForUpdate<SkillUnlockData>();`.

b. After the Skill2Pressed check, add unlock guard:
```csharp
var unlocks = SystemAPI.GetSingleton<SkillUnlockData>();
if (!unlocks.Skill2Unlocked) return;
```

c. Read stats after cooldown activation:
```csharp
var stats = SystemAPI.GetSingleton<SkillStatsData>();
```

d. Replace `GameConstants.ChainLightningMaxTargets` with `stats.ChainMaxTargets`.
e. Replace `GameConstants.ChainLightningMaxChainDist` with `stats.ChainMaxDist` (and compute `maxChainDistSq` from it).
f. Replace `GameConstants.ChainLightningDamage` with `stats.ChainDamage`.

**3. Modify `Assets/Scripts/ECS/Systems/EmpPulseSystem.cs`:**

a. In `OnCreate`, add `state.RequireForUpdate<SkillStatsData>();` and `state.RequireForUpdate<SkillUnlockData>();`.

b. After the Skill3Pressed check, add unlock guard:
```csharp
var unlocks = SystemAPI.GetSingleton<SkillUnlockData>();
if (!unlocks.Skill3Unlocked) return;
```

c. Read stats after cooldown activation:
```csharp
var stats = SystemAPI.GetSingleton<SkillStatsData>();
```

d. Replace `GameConstants.EmpPulseDamage` with `stats.EmpDamage`.
e. Replace `GameConstants.EmpPulseRadius` (for radiusSq calculation) with `stats.EmpRadius`.
f. Replace `GameConstants.EmpDotDamagePerTick` with `stats.EmpDotDamagePerTick`.
g. Replace `GameConstants.EmpDotTickInterval` with `stats.EmpDotTickInterval`.
h. Replace `GameConstants.EmpDotDuration` with `stats.EmpDotDuration`.
i. Replace `GameConstants.EmpPulseRadius` in the SkillEvent emission with `stats.EmpRadius`.

**4. Modify `Assets/Scripts/ECS/Systems/OverchargeSystem.cs`:**

a. In `OnCreate`, add `state.RequireForUpdate<SkillStatsData>();` and `state.RequireForUpdate<SkillUnlockData>();`.

b. After the Skill4Pressed and cooldown check, add unlock guard:
```csharp
var unlocks = SystemAPI.GetSingleton<SkillUnlockData>();
if (!unlocks.Skill4Unlocked) return;
```

c. Read stats:
```csharp
var stats = SystemAPI.GetSingleton<SkillStatsData>();
```

d. Replace `GameConstants.OverchargeDuration` with `stats.OverchargeDuration`.

Note: OverchargeDamageMultiplier and OverchargeRadiusMultiplier are already stored in OverchargeBuffData (set by ECSBootstrap). The OverchargeSystem only sets RemainingDuration, so only OverchargeDuration needs migration here. However, the ECSBootstrap already seeds OverchargeBuffData from GameConstants. For Phase 6 to change multipliers at runtime, the tech tree would modify OverchargeBuffData directly. No change needed here beyond duration.

**5. Modify `Assets/Scripts/ECS/Systems/SkillCooldownSystem.cs`:**

The SkillCooldownSystem currently reads max cooldown values from SkillCooldownData (which is seeded from GameConstants in ECSBootstrap). The max cooldowns are already runtime-mutable via the SkillCooldownData singleton. However, skill systems SET the cooldown from `cooldown.ValueRO.SkillNMaxCooldown`.

For Phase 6 upgradeability, the max cooldowns should come from SkillStatsData instead, so tech tree upgrades can reduce them. Modify each skill system's cooldown activation line:

Actually, looking at the code more carefully: each skill system does `cooldown.ValueRW.Skill1Remaining = cooldown.ValueRO.Skill1MaxCooldown;`. The MaxCooldown values in SkillCooldownData are already runtime-mutable. But having BOTH SkillCooldownData.MaxCooldown AND SkillStatsData cooldown fields would be confusing duplication.

**Better approach:** Remove the MaxCooldown fields from SkillCooldownData and have skill systems read cooldown from SkillStatsData directly:

a. In each skill system's activation line, replace:
   - `cooldown.ValueRW.Skill1Remaining = cooldown.ValueRO.Skill1MaxCooldown;`
   with:
   - `cooldown.ValueRW.Skill1Remaining = stats.LaserCooldown;`
   (and similarly for Skill2/Chain, Skill3/EMP, Skill4/Overcharge)

b. In `SkillCooldownSystem.cs`, the MaxCooldown fields are only used to avoid negative values and nowhere else in the system itself. The cooldown system just decrements `Remaining` -- it never reads `MaxCooldown`. So the MaxCooldown fields can remain in SkillCooldownData for now (they are read by SkillBarController for `fillAmount` calculation).

c. **Update SkillBarController** to read max cooldowns from SkillStatsData instead of SkillCooldownData for the fill ratio. In `LateUpdate()`:
   - Read `SkillStatsData` singleton (add entity field and query in TryInitECS)
   - Replace `cooldowns.Skill1MaxCooldown` with `stats.LaserCooldown` in the UpdateSlot calls
   - This ensures the UI cooldown fill matches the actual cooldown the system uses

This means SkillCooldownData.MaxCooldown fields become unused. They can be left in place (no harm) or removed. Leave them -- removing fields from a struct used across multiple files risks cascade issues and the cleanup is trivial for Phase 6.
  </action>
  <verify>
Open the project in Unity Editor. Verify no compilation errors. Enter Play Mode. Verify:
1. Press 1-4: All four skills still fire correctly with same damage, cooldown, and radius behavior as before.
2. Cooldown UI still shows correct fill ratios and countdown numbers.
3. DoT burning still applies from Laser Burst and EMP Pulse with same duration/damage.
4. In Entity Debugger, verify SkillStatsData values match GameConstants defaults.
5. Temporarily modify a SkillStatsData value in Entity Debugger (e.g., set LaserDamage to 500) and verify the change takes effect on next Laser Burst activation -- confirming runtime mutability.
  </verify>
  <done>
All 4 skill systems and SkillBarController read damage, cooldown, radius, and DoT values from SkillStatsData singleton. Skill systems guard activation on SkillUnlockData. GameConstants values are preserved as seed defaults. Phase 6 tech tree can modify SkillStatsData at runtime to upgrade skills without touching any system code. SkillCooldownData.MaxCooldown fields left in place but skill systems and UI now read from SkillStatsData.
  </done>
</task>

</tasks>

<verification>
1. **Unlock gating**: SkillUnlockData singleton exists with all 4 booleans true. SkillBarController hides slots for locked skills. Skill systems guard on unlock state.
2. **Runtime-mutable stats**: SkillStatsData singleton exists with all skill parameters. Modifying a value in Entity Debugger immediately affects skill behavior on next activation.
3. **No behavioral regression**: All 4 skills fire with identical damage, cooldown, radius, and DoT behavior as before gap closure.
4. **Phase 6 ready**: Setting `SkillUnlockData.Skill1Unlocked = false` hides the Laser Burst slot and prevents activation. Changing `SkillStatsData.LaserDamage` changes Laser Burst damage. No skill system code changes needed.
5. **No compilation errors**, no runtime exceptions.
</verification>

<success_criteria>
- SkillUnlockData and SkillStatsData ECS singletons bootstrapped with correct defaults
- SkillBarController shows/hides slots based on unlock state
- All 5 skill systems read from SkillStatsData instead of GameConstants
- All 4 skill systems guard activation on SkillUnlockData
- Gameplay behavior is unchanged from before gap closure
- Runtime modification of SkillStatsData values takes effect on next skill activation
</success_criteria>

<output>
After completion, create `.planning/phases/05-ship-skills-and-advanced-damage/05-03-SUMMARY.md`
</output>
