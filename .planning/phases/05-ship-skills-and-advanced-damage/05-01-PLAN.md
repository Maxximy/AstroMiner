---
phase: 05-ship-skills-and-advanced-damage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Assets/Scripts/ECS/Components/SkillComponents.cs
  - Assets/Scripts/ECS/Systems/SkillCooldownSystem.cs
  - Assets/Scripts/ECS/Systems/LaserBurstSystem.cs
  - Assets/Scripts/ECS/Systems/ChainLightningSystem.cs
  - Assets/Scripts/ECS/Systems/EmpPulseSystem.cs
  - Assets/Scripts/ECS/Systems/OverchargeSystem.cs
  - Assets/Scripts/ECS/Systems/BurningDamageSystem.cs
  - Assets/Scripts/ECS/Systems/MiningDamageSystem.cs
  - Assets/Scripts/ECS/Components/FeedbackComponents.cs
  - Assets/Scripts/MonoBehaviours/Bridge/InputBridge.cs
  - Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
  - Assets/Scripts/Shared/GameConstants.cs
autonomous: true
requirements: [SKIL-01, SKIL-02, SKIL-03, SKIL-04, SKIL-05, SKIL-07, SKIL-08, DMGS-01, DMGS-02]

must_haves:
  truths:
    - "Pressing keyboard keys 1-4 during Playing phase activates the corresponding skill"
    - "Laser Burst damages all asteroids in a line from ship to mouse position"
    - "Chain Lightning hits the nearest asteroid to mouse then chains to 3-4 nearby asteroids"
    - "EMP Pulse deals AoE damage to all asteroids within blast radius centered on mouse position"
    - "Overcharge temporarily doubles mining circle damage and increases radius by 1.5x"
    - "Each skill has a cooldown period during which it cannot be reactivated"
    - "Normal mining damage and skill damage can randomly crit at 5-10% chance for 2x multiplied damage"
    - "Laser Burst and EMP Pulse apply a burning DoT effect that ticks damage over 2-3 seconds"
    - "Burning DoT is removed when duration expires"
  artifacts:
    - path: "Assets/Scripts/ECS/Components/SkillComponents.cs"
      provides: "SkillInputData, SkillCooldownData, CritConfigData, OverchargeBuffData, BurningData singletons/components"
    - path: "Assets/Scripts/ECS/Systems/SkillCooldownSystem.cs"
      provides: "Cooldown decrement each frame"
    - path: "Assets/Scripts/ECS/Systems/LaserBurstSystem.cs"
      provides: "Line damage from ship to mouse"
    - path: "Assets/Scripts/ECS/Systems/ChainLightningSystem.cs"
      provides: "Chain target damage across nearby asteroids"
    - path: "Assets/Scripts/ECS/Systems/EmpPulseSystem.cs"
      provides: "AoE damage at mouse position"
    - path: "Assets/Scripts/ECS/Systems/OverchargeSystem.cs"
      provides: "Temporary buff application and expiry"
    - path: "Assets/Scripts/ECS/Systems/BurningDamageSystem.cs"
      provides: "Per-entity DoT tick damage"
    - path: "Assets/Scripts/ECS/Components/FeedbackComponents.cs"
      provides: "SkillEvent IBufferElementData for VFX bridge"
  key_links:
    - from: "Assets/Scripts/MonoBehaviours/Bridge/InputBridge.cs"
      to: "SkillInputData singleton"
      via: "Keyboard.current digit keys write each frame"
      pattern: "digit[1-4]Key\\.wasPressedThisFrame"
    - from: "Assets/Scripts/ECS/Systems/LaserBurstSystem.cs"
      to: "DamageEvent buffer + SkillEvent buffer"
      via: "System writes damage events and skill VFX events"
      pattern: "damageBuffer\\.Add.*SkillEvent"
    - from: "Assets/Scripts/ECS/Systems/MiningDamageSystem.cs"
      to: "CritConfigData singleton"
      via: "Crit roll on each damage tick"
      pattern: "CritConfigData.*NextFloat.*CritChance"
    - from: "Assets/Scripts/ECS/Systems/BurningDamageSystem.cs"
      to: "BurningData per-entity component"
      via: "Tick accumulator decrements duration, emits DamageEvent, removes component at expiry"
      pattern: "BurningData.*RemainingDuration"
---

<objective>
Build all ECS skill systems, critical hit integration, and DoT burning -- the complete damage-dealing backend for Phase 5.

Purpose: This plan creates the four skill damage systems (Laser Burst, Chain Lightning, EMP Pulse, Overcharge), extends the input bridge for keyboard activation, adds critical hit rolls to all damage sources, implements the DoT burning system, and sets up the SkillEvent buffer for VFX consumption in Plan 02. After this plan, all skill damage is functional in ECS -- Plan 02 adds the UI and visual effects.

Output: 7 new ECS files (components + systems), 4 modified files (InputBridge, ECSBootstrap, MiningDamageSystem, GameConstants), 1 modified + extended (FeedbackComponents)
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ship-skills-and-advanced-damage/05-RESEARCH.md
@.planning/phases/04-visual-and-audio-feedback/04-01-SUMMARY.md
@.planning/phases/04-visual-and-audio-feedback/04-02-SUMMARY.md

Key existing files to read before implementing:
@Assets/Scripts/ECS/Components/GameStateComponents.cs
@Assets/Scripts/ECS/Components/AsteroidComponents.cs
@Assets/Scripts/ECS/Components/FeedbackComponents.cs
@Assets/Scripts/ECS/Systems/MiningDamageSystem.cs
@Assets/Scripts/MonoBehaviours/Bridge/InputBridge.cs
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
@Assets/Scripts/Shared/GameConstants.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill ECS components, extend InputBridge, bootstrap singletons, and add SkillEvent buffer</name>
  <files>
    Assets/Scripts/ECS/Components/SkillComponents.cs
    Assets/Scripts/ECS/Components/FeedbackComponents.cs
    Assets/Scripts/MonoBehaviours/Bridge/InputBridge.cs
    Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
    Assets/Scripts/Shared/GameConstants.cs
  </files>
  <action>
**1. Create `Assets/Scripts/ECS/Components/SkillComponents.cs`** in namespace `ECS.Components` with these unmanaged IComponentData structs:

```csharp
// Singleton: written by InputBridge each frame (keyboard + UI button activation)
public struct SkillInputData : IComponentData
{
    public bool Skill1Pressed;  // Laser Burst (key 1)
    public bool Skill2Pressed;  // Chain Lightning (key 2)
    public bool Skill3Pressed;  // EMP Pulse (key 3)
    public bool Skill4Pressed;  // Overcharge (key 4)
}

// Singleton: tracks remaining and max cooldown for each skill
public struct SkillCooldownData : IComponentData
{
    public float Skill1Remaining; public float Skill1MaxCooldown; // Laser: 8s
    public float Skill2Remaining; public float Skill2MaxCooldown; // Chain: 10s
    public float Skill3Remaining; public float Skill3MaxCooldown; // EMP: 12s
    public float Skill4Remaining; public float Skill4MaxCooldown; // Overcharge: 15s
}

// Singleton: crit chance and multiplier (read by all damage systems)
public struct CritConfigData : IComponentData
{
    public float CritChance;     // 0.08 (8%)
    public float CritMultiplier; // 2.0
}

// Singleton: tracks active overcharge buff (if remaining > 0, buff is active)
public struct OverchargeBuffData : IComponentData
{
    public float RemainingDuration;  // 0 = no buff
    public float DamageMultiplier;   // 2.0 when active
    public float RadiusMultiplier;   // 1.5 when active
}

// Per-entity component: added to burning asteroids by skill systems
public struct BurningData : IComponentData
{
    public float DamagePerTick;
    public float TickInterval;
    public float RemainingDuration;
    public float TickAccumulator;
}
```

**2. Add SkillEvent to `Assets/Scripts/ECS/Components/FeedbackComponents.cs`:**

Add this buffer element struct at the end of the file (same namespace `ECS.Components`):

```csharp
/// <summary>
/// Buffer element emitted by skill systems for VFX bridge consumption.
/// Carries activation data so MonoBehaviour can render beam/lightning/blast/overcharge visuals.
/// </summary>
public struct SkillEvent : IBufferElementData
{
    public byte SkillType;       // 0=Laser, 1=Chain, 2=EMP, 3=Overcharge
    public float2 OriginPos;     // Ship position (XZ)
    public float2 TargetPos;     // Mouse position (XZ)
    // Chain lightning target positions (XZ coords, up to 4 chain targets)
    public float2 Chain1;
    public float2 Chain2;
    public float2 Chain3;
    public float2 Chain4;
    public int ChainCount;       // Number of valid chain targets (0-4)
    public float Radius;         // For EMP blast radius visual
}
```

Requires adding `using Unity.Mathematics;` if not already present.

**3. Extend `Assets/Scripts/MonoBehaviours/Bridge/InputBridge.cs`:**

- Add a new field `private Entity skillInputEntity;`
- In `Start()`, after `inputEntity` query, add: `skillInputEntity = em.CreateEntityQuery(typeof(SkillInputData)).GetSingletonEntity();`
- In `Update()`, after setting `em.SetComponentData(inputEntity, inputData);`, add:

```csharp
// Skill activation input (keyboard keys 1-4, New Input System only)
var skillInput = new SkillInputData();
var keyboard = Keyboard.current;
if (keyboard != null)
{
    skillInput.Skill1Pressed = keyboard.digit1Key.wasPressedThisFrame;
    skillInput.Skill2Pressed = keyboard.digit2Key.wasPressedThisFrame;
    skillInput.Skill3Pressed = keyboard.digit3Key.wasPressedThisFrame;
    skillInput.Skill4Pressed = keyboard.digit4Key.wasPressedThisFrame;
}
em.SetComponentData(skillInputEntity, skillInput);
```

Add `using ECS.Components;` import for SkillInputData (likely already imported).

**4. Extend `Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs`:**

After existing singleton/buffer creation, add:

```csharp
// Phase 5: Skill system singletons
var skillInputEntity = em.CreateEntity(typeof(SkillInputData));
em.SetComponentData(skillInputEntity, new SkillInputData());

var skillCooldownEntity = em.CreateEntity(typeof(SkillCooldownData));
em.SetComponentData(skillCooldownEntity, new SkillCooldownData
{
    Skill1MaxCooldown = GameConstants.LaserBurstCooldown,
    Skill2MaxCooldown = GameConstants.ChainLightningCooldown,
    Skill3MaxCooldown = GameConstants.EmpPulseCooldown,
    Skill4MaxCooldown = GameConstants.OverchargeCooldown
});

var critConfigEntity = em.CreateEntity(typeof(CritConfigData));
em.SetComponentData(critConfigEntity, new CritConfigData
{
    CritChance = GameConstants.CritChance,
    CritMultiplier = GameConstants.CritMultiplier
});

var overchargeBuffEntity = em.CreateEntity(typeof(OverchargeBuffData));
em.SetComponentData(overchargeBuffEntity, new OverchargeBuffData
{
    RemainingDuration = 0f,
    DamageMultiplier = GameConstants.OverchargeDamageMultiplier,
    RadiusMultiplier = GameConstants.OverchargeRadiusMultiplier
});

// Phase 5: SkillEvent buffer entity
var skillEventEntity = em.CreateEntity();
em.AddBuffer<SkillEvent>(skillEventEntity);
```

Update the Debug.Log to include the new singletons.

**5. Add skill constants to `Assets/Scripts/Shared/GameConstants.cs`:**

Add a new section after Audio Defaults:

```csharp
// -- Skill Defaults -------------------------------------------------------

public const float LaserBurstCooldown = 8f;
public const float LaserBurstDamage = 150f;
public const float LaserBurstBeamHalfWidth = 0.25f;

public const float ChainLightningCooldown = 10f;
public const float ChainLightningDamage = 60f;
public const int ChainLightningMaxTargets = 4;
public const float ChainLightningMaxChainDist = 5f;

public const float EmpPulseCooldown = 12f;
public const float EmpPulseDamage = 80f;
public const float EmpPulseRadius = 4f;

public const float OverchargeCooldown = 15f;
public const float OverchargeDuration = 5f;
public const float OverchargeDamageMultiplier = 2f;
public const float OverchargeRadiusMultiplier = 1.5f;

// -- Critical Hit Defaults -----------------------------------------------

public const float CritChance = 0.08f;        // 8% base crit rate
public const float CritMultiplier = 2f;        // 2x damage on crit

// -- DoT Burning Defaults ------------------------------------------------

public const float LaserDotDamagePerTick = 5f;
public const float LaserDotTickInterval = 0.5f;
public const float LaserDotDuration = 3f;

public const float EmpDotDamagePerTick = 3f;
public const float EmpDotTickInterval = 0.5f;
public const float EmpDotDuration = 2f;
```
  </action>
  <verify>
Open the project in Unity Editor. Verify no compilation errors in the Console. Enter Play Mode and confirm the ECS Bootstrap log message includes the new singletons. Verify InputBridge does not throw errors. Check that `SkillInputData`, `SkillCooldownData`, `CritConfigData`, `OverchargeBuffData`, and `SkillEvent` buffer entities exist in the Entity Debugger.
  </verify>
  <done>
All skill ECS components defined, InputBridge reads keyboard 1-4 via new Input System, ECSBootstrap creates all Phase 5 singletons and SkillEvent buffer, GameConstants has all skill/crit/DoT tuning values. Zero compilation errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement all skill systems, crit integration in MiningDamageSystem, and BurningDamageSystem</name>
  <files>
    Assets/Scripts/ECS/Systems/SkillCooldownSystem.cs
    Assets/Scripts/ECS/Systems/LaserBurstSystem.cs
    Assets/Scripts/ECS/Systems/ChainLightningSystem.cs
    Assets/Scripts/ECS/Systems/EmpPulseSystem.cs
    Assets/Scripts/ECS/Systems/OverchargeSystem.cs
    Assets/Scripts/ECS/Systems/BurningDamageSystem.cs
    Assets/Scripts/ECS/Systems/MiningDamageSystem.cs
  </files>
  <action>
**CRITICAL RULES for all ISystem implementations:**
- `[BurstCompile]` on struct and OnUpdate ONLY -- NEVER on OnCreate
- All systems must guard `gameState.Phase != GamePhase.Playing` at top of OnUpdate
- Use `Unity.Mathematics.Random` for crit rolls (seed in OnCreate from `(uint)System.Environment.TickCount`)
- Use `SystemAPI.GetSingletonBuffer<DamageEvent>()` and `SystemAPI.GetSingletonBuffer<SkillEvent>()` for event emission
- Use `EndSimulationEntityCommandBufferSystem` ECB for structural changes (adding/removing BurningData)

**1. Create `SkillCooldownSystem.cs`** (namespace `ECS.Systems`):
- `[BurstCompile] public partial struct SkillCooldownSystem : ISystem`
- OnCreate: `state.RequireForUpdate<SkillCooldownData>();`
- OnUpdate: Read `SystemAPI.Time.DeltaTime`, get `SkillCooldownData` singleton RW, decrement each `SkillNRemaining` by dt, clamp to 0 via `math.max(0f, ...)`. Update with `[UpdateBefore(typeof(LaserBurstSystem))]`.

**2. Create `LaserBurstSystem.cs`:**
- `[BurstCompile] public partial struct LaserBurstSystem : ISystem`
- OnCreate: RequireForUpdate on SkillInputData, SkillCooldownData, InputData, GameStateData. Initialize `Unity.Mathematics.Random rng` field.
- OnUpdate:
  - Guard: Playing phase only
  - Read SkillInputData. If `!Skill1Pressed`, return early.
  - Read SkillCooldownData. If `Skill1Remaining > 0`, return (on cooldown).
  - Set `cooldown.ValueRW.Skill1Remaining = cooldown.ValueRO.Skill1MaxCooldown;`
  - Read InputData for mouse position. Compute line from ship `(GameConstants.ShipPositionX, GameConstants.ShipPositionZ)` to mouse position.
  - Read CritConfigData for crit rolls.
  - Get ECB from `SystemAPI.GetSingleton<EndSimulationEntityCommandBufferSystem.Singleton>().CreateCommandBuffer(state.WorldUnmanaged)`.
  - For each asteroid (query `RefRO<LocalTransform>, RefRW<HealthData>` WithAll`<AsteroidTag>`):
    - Compute point-to-segment distance squared on XZ plane.
    - If `distSq <= (asteroidRadius + beamHalfWidth)^2` where `asteroidRadius` = `transform.Scale * 0.5f` (approximate), apply damage.
    - Roll crit: `bool isCrit = rng.NextFloat() < critConfig.CritChance;`
    - `float damage = isCrit ? LaserBurstDamage * critConfig.CritMultiplier : LaserBurstDamage;`
    - `health.ValueRW.CurrentHP -= damage;`
    - Emit DamageEvent with `Type = isCrit ? DamageType.Critical : DamageType.Skill`, color cyan `(0, 255, 255)`.
    - Apply DoT: check `SystemAPI.HasComponent<BurningData>(entity)`. If yes, `ecb.SetComponent(entity, new BurningData{...})` to refresh. If no, `ecb.AddComponent(entity, new BurningData{ DamagePerTick=LaserDotDamagePerTick, TickInterval=LaserDotTickInterval, RemainingDuration=LaserDotDuration, TickAccumulator=0 })`.
  - Emit SkillEvent with `SkillType=0, OriginPos=shipPos, TargetPos=mousePos`.

  **Point-to-segment distance function** (static, Burst-compatible):
  ```csharp
  static float PointToSegmentDistSq(float2 p, float2 a, float2 b)
  {
      float2 ab = b - a;
      float2 ap = p - a;
      float abLenSq = math.dot(ab, ab);
      if (abLenSq < 0.0001f) return math.distancesq(p, a);
      float t = math.saturate(math.dot(ap, ab) / abLenSq);
      float2 closest = a + t * ab;
      return math.distancesq(p, closest);
  }
  ```

**3. Create `ChainLightningSystem.cs`:**
- Same Burst ISystem pattern as LaserBurst.
- OnUpdate: If Skill2Pressed and cooldown ready, set cooldown.
- Step 1: Find nearest asteroid to mouse position (iterate all, track min distSq and entity).
- Step 2: From primary target, iterate up to `ChainLightningMaxTargets - 1` more times, each finding nearest unvisited asteroid within `ChainLightningMaxChainDist` of the LAST hit target. Track visited entities in a `NativeList<Entity>` (allocate Temp).
- Apply damage + crit roll to each target. Emit DamageEvent per target with `Type = isCrit ? DamageType.Critical : DamageType.Skill`, color blue `(128, 179, 255)`.
- NOTE: Chain Lightning does NOT apply DoT (per research discretion recommendation).
- Emit single SkillEvent with `SkillType=1`, OriginPos=shipPos, TargetPos=firstTarget position, Chain1-4=chain target positions, ChainCount=number of chain targets.
- Must use `foreach` with `EntityQuery` that provides Entity alongside components. Use `SystemAPI.Query<RefRO<LocalTransform>, RefRW<HealthData>, RefRO<AsteroidTag>>().WithEntityAccess()` (or the `Entity` variant) to get entity references for visited tracking.

**4. Create `EmpPulseSystem.cs`:**
- Same pattern. If Skill3Pressed and cooldown ready, set cooldown.
- Simple circle-vs-point: for each asteroid, compute `distSq` from mouse position. If `distSq <= EmpPulseRadius * EmpPulseRadius`, apply damage + crit roll.
- Apply DoT (EMP burn): same add/set BurningData pattern as LaserBurst but with `EmpDotDamagePerTick`, `EmpDotTickInterval`, `EmpDotDuration`.
- Emit DamageEvent per hit with `DamageType.Skill` or `DamageType.Critical`, color purple `(180, 100, 255)`.
- Emit SkillEvent with `SkillType=2`, TargetPos=mousePos, Radius=EmpPulseRadius.

**5. Create `OverchargeSystem.cs`:**
- Reads SkillInputData. If Skill4Pressed and cooldown ready:
  - Set cooldown.
  - Set `OverchargeBuffData.RemainingDuration = OverchargeDuration`.
- Every frame: if `OverchargeBuffData.RemainingDuration > 0`, decrement by dt. If reaches 0, buff expires (no explicit reset needed -- MiningDamageSystem checks remaining > 0).
- Emit SkillEvent with `SkillType=3` ONLY on activation (when pressed), not every frame.

**6. Create `BurningDamageSystem.cs`:**
- `[BurstCompile] public partial struct BurningDamageSystem : ISystem`
- Queries all entities with `BurningData` (and `HealthData`) via `SystemAPI.Query<RefRW<BurningData>, RefRW<HealthData>, RefRO<LocalTransform>>().WithEntityAccess()`.
- Each frame:
  - Decrement `BurningData.RemainingDuration` by dt.
  - Accumulate `TickAccumulator += dt`.
  - While `TickAccumulator >= TickInterval`: subtract interval, apply DamagePerTick to health, emit DamageEvent with `DamageType.Normal` (white style per user decision: "DoT damage popups use same white style as normal damage"). Color white `(255, 255, 255)`.
  - If `RemainingDuration <= 0`: use ECB to `RemoveComponent<BurningData>(entity)`.
- DoT ticks CAN crit (per research: "Both skills and normal mining damage can crit"). Read CritConfigData and roll.

**7. Modify `MiningDamageSystem.cs`:**
- Add crit roll integration. In OnCreate, initialize `Unity.Mathematics.Random rng` field.
- Read `CritConfigData` singleton at start of OnUpdate.
- Read `OverchargeBuffData` singleton. If `RemainingDuration > 0`, multiply `config.DamagePerTick` by `overchargeBuff.DamageMultiplier` and `config.Radius` by `overchargeBuff.RadiusMultiplier`.
- On each damage tick: roll crit. If crit, multiply damage by `critConfig.CritMultiplier` and set `DamageType.Critical` on the DamageEvent (replacing `DamageType.Normal`).
- Keep DamageEvent color white `(255, 255, 255)` for normal mining hits, but critical hits will be styled by the popup system based on `DamageType.Critical`.
  </action>
  <verify>
Open Unity Editor, verify zero compilation errors. Enter Play Mode. Verify:
1. Press 1 -- Laser burst applies damage to asteroids in a line (watch health drop in Entity Debugger or see damage popups)
2. Press 2 -- Chain Lightning hits nearest asteroid and chains
3. Press 3 -- EMP Pulse hits all nearby asteroids
4. Press 4 -- Overcharge makes mining circle deal more damage (check MiningDamageSystem output)
5. Mining circle damage occasionally crits (yellow CRIT! popups appear since FeedbackEventBridge already handles DamageType.Critical)
6. Asteroids hit by Laser/EMP have BurningData component (verify in Entity Debugger) and take periodic damage
7. Skills respect cooldowns (pressing key during cooldown does nothing)
  </verify>
  <done>
All four skills deal damage via ECS systems with correct targeting (line/chain/AoE/buff). Crit rolls integrated into mining and all skill systems. BurningDamageSystem ticks DoT on burning asteroids and removes BurningData on expiry. SkillEvent buffer populated for Plan 02 VFX consumption. Cooldowns enforced.
  </done>
</task>

</tasks>

<verification>
1. **Skill activation**: Keys 1-4 activate skills during Playing phase only. No activation during other phases.
2. **Cooldowns**: After activation, skill cannot re-fire until cooldown timer reaches 0. Verify with rapid key presses.
3. **Laser Burst**: Damage numbers appear on asteroids in a line from ship to mouse. DoT ticks visible on hit asteroids.
4. **Chain Lightning**: Primary target near mouse takes damage, then 3-4 nearby asteroids take damage in chain order.
5. **EMP Pulse**: All asteroids within blast radius at mouse position take damage. DoT ticks visible.
6. **Overcharge**: Mining circle damage visibly increases (larger damage numbers) for 5 seconds.
7. **Critical hits**: Yellow "CRIT!" popups appear at ~8% rate on mining ticks and skill hits. Camera shakes on crits.
8. **DoT burning**: Asteroids hit by Laser/EMP continue taking damage after skill fires (visible as periodic white damage popups).
9. **No compilation errors**, no runtime exceptions in Console.
</verification>

<success_criteria>
- 7 new ECS files compile and systems run during Playing phase
- 4 skills fire correctly with distinct targeting patterns
- Cooldowns prevent re-activation
- Crit system produces DamageType.Critical events at ~8% rate
- BurningData added/removed/refreshed correctly on asteroids
- SkillEvent buffer populated for Plan 02 VFX consumption
- Overcharge buff multiplies mining damage and radius temporarily
</success_criteria>

<output>
After completion, create `.planning/phases/05-ship-skills-and-advanced-damage/05-01-SUMMARY.md`
</output>
