---
phase: 02-core-mining-loop
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - Assets/Scripts/ECS/Systems/MiningDamageSystem.cs
  - Assets/Scripts/MonoBehaviours/Rendering/MiningCircleVisual.cs
  - Assets/Scripts/MonoBehaviours/Core/GameManager.cs
autonomous: false
requirements:
  - MINE-01
  - MINE-02
  - MINE-03
  - MINE-04
  - MINE-05

must_haves:
  truths:
    - "A cyan glowing circle follows the mouse cursor on the gameplay plane"
    - "Asteroids within the mining circle take damage over time at a configurable tick rate"
    - "Asteroids reaching 0 HP are destroyed and visually removed from play"
    - "Mining circle radius and damage values are configurable via MiningConfigData singleton"
    - "The mining circle visually glows with bloom effect"
  artifacts:
    - path: "Assets/Scripts/ECS/Systems/MiningDamageSystem.cs"
      provides: "Tick-based AoE damage to asteroids within mining radius"
      contains: "MiningDamageSystem"
    - path: "Assets/Scripts/MonoBehaviours/Rendering/MiningCircleVisual.cs"
      provides: "LineRenderer circle following mouse with HDR emissive bloom glow"
      contains: "MiningCircleVisual"
  key_links:
    - from: "MiningDamageSystem"
      to: "InputData.MouseWorldPos"
      via: "SystemAPI.GetSingleton<InputData>() for cursor position"
      pattern: "InputData.*MouseWorldPos"
    - from: "MiningDamageSystem"
      to: "HealthData.CurrentHP"
      via: "Subtracts DamagePerTick when DamageTickTimer fires"
      pattern: "CurrentHP.*DamagePerTick"
    - from: "MiningDamageSystem"
      to: "MiningConfigData"
      via: "Reads Radius, DamagePerTick, TickInterval from singleton"
      pattern: "MiningConfigData"
    - from: "MiningCircleVisual"
      to: "InputData.MouseWorldPos"
      via: "Reads mouse position each frame and positions circle GameObject"
      pattern: "InputData.*MouseWorldPos"
    - from: "AsteroidDestructionSystem (02-01)"
      to: "HealthData.CurrentHP <= 0"
      via: "Destroys entity when HP depleted by MiningDamageSystem"
      pattern: "CurrentHP.*<=.*0"
---

<objective>
Implement the mining circle that follows the mouse cursor with a glowing cyan ring visual, and the tick-based AoE damage system that depletes asteroid HP when they are within the mining circle radius. This completes the core mining interaction: hover over asteroids, watch their HP drain, see them destroyed.

Purpose: This is THE core interaction of the game -- the mining circle is what the player controls, and watching asteroids break apart under sustained mining is the fundamental satisfaction loop.

Output: MiningDamageSystem (ECS), MiningCircleVisual (MonoBehaviour with LineRenderer + HDR bloom), updated GameManager to remove debug key shortcuts.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-mining-loop/02-RESEARCH.md
@.planning/phases/02-core-mining-loop/02-01-SUMMARY.md

# Key files from Plan 02-01 (needed for component/system understanding):
@Assets/Scripts/ECS/Components/AsteroidComponents.cs
@Assets/Scripts/ECS/Components/GameStateComponents.cs
@Assets/Scripts/Shared/GameConstants.cs
@Assets/Scripts/MonoBehaviours/Bridge/InputBridge.cs
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MiningDamageSystem and MiningCircleVisual</name>
  <files>
    Assets/Scripts/ECS/Systems/MiningDamageSystem.cs
    Assets/Scripts/MonoBehaviours/Rendering/MiningCircleVisual.cs
    Assets/Scripts/MonoBehaviours/Core/GameManager.cs
  </files>
  <action>
    **1. Create `Assets/Scripts/ECS/Systems/MiningDamageSystem.cs`:**
    `[BurstCompile] public partial struct MiningDamageSystem : ISystem`

    OnUpdate implementation:
    - Guard: `if (!SystemAPI.HasSingleton<GameStateData>()) return;`
    - Guard: `var gameState = SystemAPI.GetSingleton<GameStateData>(); if (gameState.Phase != GamePhase.Playing) return;`
    - Read input: `var input = SystemAPI.GetSingleton<InputData>(); if (!input.MouseValid) return;`
    - Read mining config: `var config = SystemAPI.GetSingleton<MiningConfigData>();`
    - Compute: `float radiusSq = config.Radius * config.Radius;`
    - Get deltaTime: `float dt = SystemAPI.Time.DeltaTime;`
    - Iterate all asteroids: `foreach (var (transform, health, tickTimer) in SystemAPI.Query<RefRO<LocalTransform>, RefRW<HealthData>, RefRW<DamageTickTimer>>().WithAll<AsteroidTag>())`
    - **COORDINATE MAPPING:** InputBridge writes `float2(worldPoint.x, worldPoint.z)` -- the mouse position IS on the XZ plane. Asteroid entities (from Plan 02-01) are at `(x, 0, z)` on the XZ plane. So the distance check is: `float2 asteroidPos = new float2(transform.ValueRO.Position.x, transform.ValueRO.Position.z); float distSq = math.distancesq(asteroidPos, input.MouseWorldPos);`
    - If `distSq <= radiusSq` (inside mining circle):
      - Accumulate timer: `tickTimer.ValueRW.Elapsed += dt;`
      - If `tickTimer.ValueRO.Elapsed >= config.TickInterval`:
        - Apply damage: `health.ValueRW.CurrentHP -= config.DamagePerTick;`
        - Reset timer: `tickTimer.ValueRW.Elapsed -= config.TickInterval;` (subtract, not reset to 0, to preserve fractional accumulation)
    - Else (outside mining circle):
      - Reset timer: `tickTimer.ValueRW.Elapsed = 0f;` (damage timer resets when asteroid leaves circle)

    Required usings: `Unity.Burst, Unity.Entities, Unity.Mathematics, Unity.Transforms`

    **2. Create `Assets/Scripts/MonoBehaviours/Rendering/MiningCircleVisual.cs`:**
    Create the directory `Assets/Scripts/MonoBehaviours/Rendering/` if it doesn't exist.

    MonoBehaviour that creates and positions a glowing cyan ring at the mouse world position.

    Fields:
    - `private LineRenderer _lineRenderer;`
    - `private Material _circleMaterial;`
    - `private EntityManager _em;`
    - `private Entity _inputEntity;`
    - `private Entity _miningConfigEntity;`
    - `private bool _initialized;`
    - Serialized: `[SerializeField] private int _segments = 64;` (circle resolution)
    - Serialized: `[SerializeField] private float _lineWidth = 0.08f;`
    - Serialized: `[SerializeField] private float _hdrIntensity = 4f;` (multiplier for bloom, must be above 0.8 threshold)

    Start / Init (coroutine, wait one frame for ECS):
    - Get EntityManager from World.DefaultGameObjectInjectionWorld
    - Get input entity: `_em.CreateEntityQuery(typeof(InputData)).GetSingletonEntity()`
    - Get mining config entity: `_em.CreateEntityQuery(typeof(MiningConfigData)).GetSingletonEntity()`
    - Create child GameObject "MiningCircleRing" or use self
    - Add LineRenderer component (or GetComponent if on same GO):
      - `positionCount = _segments`
      - `loop = true`
      - `useWorldSpace = false` (positions relative to transform)
      - `startWidth = _lineWidth`, `endWidth = _lineWidth`
      - `shadowCastingMode = ShadowCastingMode.Off`
      - `receiveShadows = false`
    - Generate circle points on XZ plane (Y=0 relative, X/Z form unit circle):
      ```
      for (int i = 0; i < _segments; i++)
      {
          float angle = (float)i / _segments * Mathf.PI * 2f;
          float x = Mathf.Cos(angle);
          float z = Mathf.Sin(angle);
          _lineRenderer.SetPosition(i, new Vector3(x, 0f, z));
      }
      ```
      These are unit-circle positions; the parent transform's scale controls actual radius.
    - Create HDR emissive material:
      - `_circleMaterial = new Material(Shader.Find("Universal Render Pipeline/Unlit"));`
      - `Color hdrCyan = new Color(0f, 1f, 1f) * _hdrIntensity;` (HDR color well above bloom threshold)
      - `_circleMaterial.SetColor("_BaseColor", hdrCyan);`
      - `_lineRenderer.material = _circleMaterial;`
    - Read initial radius from MiningConfigData singleton and set transform.localScale
    - Set `_initialized = true`

    Update (every frame):
    - If not initialized, return
    - Read InputData from ECS: `var input = _em.GetComponentData<InputData>(_inputEntity);`
    - If `input.MouseValid`:
      - Position the circle: `transform.position = new Vector3(input.MouseWorldPos.x, 0.05f, input.MouseWorldPos.y);` -- note: InputData.MouseWorldPos is float2(x, z), so .x maps to world X and .y maps to world Z. Position slightly above Y=0 (0.05f) to avoid z-fighting with the ground plane.
      - Read MiningConfigData for radius: `var config = _em.GetComponentData<MiningConfigData>(_miningConfigEntity);`
      - Set scale: `transform.localScale = Vector3.one * config.Radius;` (unit circle * radius = correct size)
      - Enable renderer if hidden: `_lineRenderer.enabled = true;`
    - If NOT `input.MouseValid`:
      - Hide circle: `_lineRenderer.enabled = false;`

    OnDestroy:
    - Clean up material: `if (_circleMaterial != null) Destroy(_circleMaterial);`

    **3. Update `Assets/Scripts/MonoBehaviours/Core/GameManager.cs`:**
    Remove the TODO debug key shortcuts in Update() (the `// TODO: Remove in Phase 2` block with digit1Key through digit4Key). The game now starts in Playing state and the mining interaction IS the gameplay. State transitions will be driven by game logic in Phase 3 (timer expiry, etc.), not debug keys.

    Keep the debug overlay intact (DebugOverlay is separate and still useful).

    **4. Scene setup note:**
    The user must add MiningCircleVisual to a GameObject in the scene. Options:
    - Create an empty GameObject named "MiningCircle" and attach MiningCircleVisual
    - Or attach it to the GameManager or an existing Rendering object
    The script creates its own LineRenderer component, so no manual LineRenderer setup is needed.
  </action>
  <verify>
    Enter Play mode. Verify:
    1. A cyan glowing ring appears and follows the mouse cursor smoothly
    2. The ring has visible bloom glow (halo around the cyan color)
    3. When hovering the mining circle over a drifting asteroid, the asteroid eventually disappears (HP depleted to 0)
    4. The time to destroy an asteroid is consistent with DefaultDamagePerTick (10) at DefaultTickInterval (0.25s) against DefaultAsteroidHP (100) -- approximately 2.5 seconds of sustained hover
    5. Multiple asteroids within the circle take damage simultaneously
    6. Asteroids that drift out of the circle stop taking damage (their tick timer resets)
    7. The mining circle radius visually matches the damage radius (asteroids at the edge of the visual ring are at the damage boundary)
    8. Debug key shortcuts (1-4) no longer trigger state transitions
  </verify>
  <done>
    The mining circle follows the mouse with a cyan HDR bloom ring. Asteroids within the mining radius take tick-based damage. Asteroids destroyed at 0 HP disappear from play (AsteroidDestructionSystem from Plan 02-01 handles removal). Damage rate, tick interval, and radius are all configurable via MiningConfigData singleton. The core mining interaction is playable.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify complete mining interaction</name>
  <files>None (verification only)</files>
  <action>
    Verify the complete Phase 2 core mining loop built in Task 1 and Plan 02-01:
    - Asteroids spawn at top, drift down with rotation, destroyed at bottom boundary
    - Cyan glowing mining circle follows mouse cursor with bloom effect
    - Hovering over asteroids depletes their HP via tick-based damage
    - Asteroids with 0 HP are destroyed and visually removed
    - Ship placeholder visible at bottom of screen

    Steps to verify:
    1. Enter Play mode in Unity Editor
    2. Verify asteroids (3D spheres) continuously spawn at the top and drift downward with rotation
    3. Move the mouse around -- a cyan glowing ring should follow the cursor smoothly
    4. Confirm the ring has visible bloom glow (halo/bleed around the cyan color)
    5. Hover the mining circle over a single asteroid -- it should disappear after ~2.5 seconds (100 HP / 10 damage per 0.25s tick)
    6. Hover over multiple asteroids simultaneously -- all should take damage and eventually disappear
    7. Move the cursor away from an asteroid mid-damage, then back -- the tick timer should reset (damage doesn't carry over)
    8. Verify the ship placeholder is visible near the bottom of the screen
    9. Verify asteroids that reach the bottom boundary disappear even without being mined
    10. Check Console for any errors or warnings
    11. Verify keys 1-4 no longer trigger state transitions (debug shortcuts removed)

    Resume signal: Type "approved" if the core mining loop works correctly, or describe any issues observed.
  </action>
  <verify>User confirms visual and functional correctness of the mining interaction in Play mode.</verify>
  <done>User has approved the core mining loop: asteroids spawn, drift, and break apart under the mining circle's tick-based damage with visual bloom glow.</done>
</task>

</tasks>

<verification>
Phase 2 Plan 02 overall checks:
- MiningDamageSystem reads InputData.MouseWorldPos and MiningConfigData.Radius to determine which asteroids are in range
- Distance check uses XZ coordinates consistently (mouse float2 x,z vs entity Position.x,z)
- DamageTickTimer accumulates per-asteroid, resets when asteroid leaves circle
- HealthData.CurrentHP is decremented by MiningConfigData.DamagePerTick on each tick
- AsteroidDestructionSystem (from Plan 02-01) destroys 0-HP entities
- AsteroidRenderer (from Plan 02-01) cleans up destroyed entity GameObjects
- MiningCircleVisual positions at mouse world position, scales to MiningConfigData.Radius
- LineRenderer uses HDR emissive material above bloom threshold (intensity 4x)
- Mining circle and damage radius are synchronized (same config value)
</verification>

<success_criteria>
1. A cyan emissive mining circle follows the mouse and visually glows with bloom
2. Asteroids within the mining circle take tick-based damage and their HP depletes
3. Asteroids with 0 HP are destroyed and visually removed
4. Damage rate, damage amount, and radius are configurable via MiningConfigData
5. The mining interaction feels responsive (damage starts immediately when cursor enters asteroid range)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-mining-loop/02-02-SUMMARY.md`
</output>
