---
phase: 06-tech-tree-and-level-progression
plan: 03
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs
  - Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs
  - Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs
  - Assets/Scripts/ECS/Components/AsteroidComponents.cs
  - Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs
  - Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
  - Assets/Scripts/ECS/Components/FeedbackComponents.cs
  - Assets/Scripts/States/PlayingState.cs
  - Assets/Scripts/Data/LevelConfigDefinitions.cs
  - Assets/Scripts/Data/ResourceTierDefinitions.cs
autonomous: true
requirements: [LEVL-01, LEVL-02, LEVL-03, ASTR-06]

must_haves:
  truths:
    - "5 levels exist with distinct drop tables: Level 1 Iron only, Level 5 all 6 tiers"
    - "Higher levels spawn rarer resource tiers worth more credits"
    - "Higher-level asteroids have more HP and are visually larger"
    - "6 resource tiers have distinct mineral colors: Iron grey, Copper orange, Silver white, Cobalt blue, Gold yellow, Titanium purple"
    - "Economy bonuses (ResourceMultiplier, LuckyStrike) apply during mineral collection"
    - "Run duration reads from RunConfigData singleton (modified by tech tree)"
  artifacts:
    - path: "Assets/Scripts/Data/LevelConfigDefinitions.cs"
      provides: "Runtime level config data for 5 levels with drop tables, HP multipliers"
      contains: "class LevelConfigDefinitions"
    - path: "Assets/Scripts/Data/ResourceTierDefinitions.cs"
      provides: "Runtime resource tier data: credit values, colors, emissive intensities for 6 tiers"
      contains: "class ResourceTierDefinitions"
    - path: "Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs"
      provides: "Per-level HP multiplier and resource tier assignment to asteroids"
      contains: "RunConfigData|ResourceTier"
    - path: "Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs"
      provides: "Per-tier credit values and mineral count from asteroid resource tier"
      contains: "ResourceTier|CreditValue"
    - path: "Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs"
      provides: "ResourceMultiplier and LuckyStrike bonus application"
      contains: "PlayerBonusData|ResourceMultiplier"
  key_links:
    - from: "Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs"
      to: "Assets/Scripts/ECS/Components/EconomyComponents.cs"
      via: "Reads RunConfigData for HP multiplier, spawn interval, max asteroids, current level"
      pattern: "RunConfigData"
    - from: "Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs"
      to: "Assets/Scripts/ECS/Components/EconomyComponents.cs"
      via: "Reads PlayerBonusData for ResourceMultiplier and LuckyStrikeChance"
      pattern: "PlayerBonusData"
    - from: "Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs"
      to: "Assets/Scripts/Data/ResourceTierDefinitions.cs"
      via: "Reads mineral entity ResourceTier to select color from tier definitions"
      pattern: "ResourceTier|MineralColor"
---

<objective>
Implement the level progression system and resource tier expansion: 5 levels with distinct drop tables, 6 resource tiers with distinct mineral colors, per-level asteroid HP/size scaling, economy bonus application (ResourceMultiplier, LuckyStrike), and run duration reading from the modifiable RunConfigData singleton. Asteroids and minerals become visually and economically diverse across levels.

Purpose: This plan delivers the content variety that makes level advancement meaningful -- each new level introduces rarer, more valuable resources and tougher asteroids, creating the core progression loop that motivates tech tree spending.

Output: Modified ECS systems reading from RunConfigData and PlayerBonusData, per-tier mineral colors, asteroid size scaling by HP, runtime level and resource tier definitions, economy bonus integration.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-tech-tree-and-level-progression/06-RESEARCH.md
@.planning/phases/06-tech-tree-and-level-progression/06-CONTEXT.md
@.planning/phases/06-tech-tree-and-level-progression/06-01-SUMMARY.md
@Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs
@Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs
@Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs
@Assets/Scripts/ECS/Components/AsteroidComponents.cs
@Assets/Scripts/ECS/Components/MineralComponents.cs
@Assets/Scripts/ECS/Components/EconomyComponents.cs
@Assets/Scripts/ECS/Components/FeedbackComponents.cs
@Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
@Assets/Scripts/States/PlayingState.cs
@Assets/Scripts/Shared/GameConstants.cs
@Assets/Scripts/Data/ResourceTierSO.cs
@Assets/Scripts/Data/LevelConfigSO.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand asteroid spawning with per-level HP, resource tier assignment, and size scaling</name>
  <files>
    Assets/Scripts/ECS/Components/AsteroidComponents.cs
    Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs
    Assets/Scripts/Data/LevelConfigDefinitions.cs
    Assets/Scripts/Data/ResourceTierDefinitions.cs
    Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs
    Assets/Scripts/ECS/Components/FeedbackComponents.cs
    Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs
    Assets/Scripts/States/PlayingState.cs
  </files>
  <action>
    **AsteroidComponents.cs** -- Add ResourceTier to asteroid entities:
    - Add new component: `public struct AsteroidResourceTier : IComponentData { public int Tier; }`
    - This tracks which resource tier the asteroid drops when destroyed

    **LevelConfigDefinitions.cs** -- New static class in Assets/Scripts/Data/:
    - Contains runtime level configuration data (since we create everything programmatically)
    - Define a `struct LevelConfig`:
      - `int LevelNumber`
      - `float AsteroidHPMultiplier`
      - `float SpawnIntervalOverride` (-1 for default)
      - `int MaxActiveAsteroidsOverride` (-1 for default)
      - `TierWeight[] DropTable`
    - Define `struct TierWeight { int TierIndex; float Weight; }`
    - Static method `GetLevelConfig(int level)` returns config for level 1-5:

    Level configurations (per locked decisions):
    - **Level 1:** HP mult 1.0, spawn default, drop table: Iron(100%)
    - **Level 2:** HP mult 1.3, drop table: Iron(70%), Copper(30%)
    - **Level 3:** HP mult 1.7, spawn interval 1.3s, drop table: Iron(40%), Copper(35%), Silver(25%)
    - **Level 4:** HP mult 2.2, spawn interval 1.1s, max asteroids 60, drop table: Iron(20%), Copper(25%), Silver(25%), Cobalt(30%)
    - **Level 5:** HP mult 3.0, spawn interval 0.9s, max asteroids 70, drop table: Iron(10%), Copper(15%), Silver(20%), Cobalt(20%), Gold(20%), Titanium(15%)

    Static method `int PickResourceTier(TierWeight[] dropTable, ref Unity.Mathematics.Random rng)`:
    - Weighted random selection: sum all weights, pick random 0..sum, iterate to find tier

    **ResourceTierDefinitions.cs** -- New static class in Assets/Scripts/Data/:
    - Contains runtime resource tier data for 6 tiers (ASTR-06)
    - Define `struct ResourceTierInfo`:
      - `string Name`
      - `int CreditValue`
      - `int MineralsPerAsteroid` (min/max range could be a simple average for now)
      - `Color MineralColor`
      - `float EmissiveIntensity`
    - Static array of 6 tiers with locked decision colors:
      - Iron: grey (0.6, 0.6, 0.6), credit 10, minerals 3-8, emissive 2.0
      - Copper: orange (0.9, 0.5, 0.2), credit 25, minerals 3-7, emissive 2.0
      - Silver: white (0.9, 0.9, 0.95), credit 75, minerals 2-6, emissive 2.5
      - Cobalt: blue (0.3, 0.5, 0.95), credit 150, minerals 2-5, emissive 2.5
      - Gold: yellow (1.0, 0.85, 0.2), credit 400, minerals 1-4, emissive 3.0
      - Titanium: purple/magenta (0.8, 0.3, 0.9), credit 1000, minerals 1-3, emissive 3.5
    - Static method `GetTier(int tierIndex)` returns the ResourceTierInfo

    **AsteroidSpawnSystem.cs** -- Major modifications:
    1. Add `state.RequireForUpdate<RunConfigData>();` in OnCreate
    2. In OnUpdate, read RunConfigData singleton:
       ```
       var runConfig = SystemAPI.GetSingleton<RunConfigData>();
       ```
    3. Replace hardcoded spawn interval/max asteroids with RunConfigData values:
       - Use `runConfig.SpawnInterval` instead of `spawnTimer.ValueRO.SpawnInterval` for the interval
       - Actually, keep AsteroidSpawnTimer for the countdown mechanism, but on each run start, the timer's SpawnInterval and MaxActiveAsteroids should be set from RunConfigData. Better approach: read RunConfigData values when checking the cap:
       - `if (currentCount >= runConfig.MaxActiveAsteroids)` instead of `spawnTimer.ValueRO.MaxActiveAsteroids`
       - Reset timer: `spawnTimer.ValueRW.TimeUntilNextSpawn = runConfig.SpawnInterval;`
    4. Pick resource tier for the asteroid using weighted random from level config:
       - Access level config via a static call (LevelConfigDefinitions is a static class, accessible from Burst code only if it uses unmanaged types). **Problem:** Burst-compiled ISystem cannot call managed static methods.
       - **Solution:** Store drop table data in RunConfigData or a new unmanaged singleton. Add to RunConfigData:
         - `int DropTableLength` (number of tiers in drop table, max 6)
         - `FixedBytes30 DropTierIndices` or simpler: use 6 fixed fields:
           `int Tier0Index, float Tier0Weight, int Tier1Index, float Tier1Weight, ... int Tier5Index, float Tier5Weight`
           and `int ActiveTierCount`
         - Or even simpler: just store 6 weights as a `float` field per tier in RunConfigData:
           `float TierWeight0, TierWeight1, TierWeight2, TierWeight3, TierWeight4, TierWeight5`
         - The TechTreeController (MonoBehaviour) writes these weights when the level changes.
       - Add these fields to RunConfigData (in EconomyComponents.cs, which was created in 06-01):
         ```
         public float TierWeight0, TierWeight1, TierWeight2, TierWeight3, TierWeight4, TierWeight5;
         ```
       - In AsteroidSpawnSystem, weighted random pick from these 6 weights:
         ```
         float totalWeight = runConfig.TierWeight0 + ... + runConfig.TierWeight5;
         float roll = rng.NextFloat(0, totalWeight);
         int tier = 0;
         roll -= runConfig.TierWeight0; if (roll <= 0) tier = 0; else { roll -= runConfig.TierWeight1; if (roll <= 0) tier = 1; ... }
         ```
    5. Set asteroid HP using tier + level multiplier:
       - Base HP stays at GameConstants.DefaultAsteroidHP
       - Multiply by runConfig.AsteroidHPMultiplier
       - Higher tiers could have slightly more HP (e.g., base * (1 + tier * 0.2) * levelMultiplier)
    6. Add AsteroidResourceTier component to spawned entity:
       ```
       ecb.AddComponent(entity, new AsteroidResourceTier { Tier = tier });
       ```

    **MineralSpawnSystem.cs** -- Read asteroid resource tier:
    1. Add `RefRO<AsteroidResourceTier>` to the query (alongside HealthData, LocalTransform, AsteroidTag)
    2. When spawning minerals, use the asteroid's ResourceTier:
       - Credit value per mineral: read from tier constants stored as Burst-accessible constants in GameConstants (add IronCreditValue through TitaniumCreditValue as const fields -- already added in 06-01 Task 1)
       - Mineral count: use tier-specific ranges (fewer minerals for rarer tiers but each worth more)
       - Set `MineralData.ResourceTier` to the asteroid's tier
       - Set `MineralData.CreditValue` based on tier:
         ```
         int creditValue = tier switch { 0 => GameConstants.IronCreditValue, 1 => GameConstants.CopperCreditValue, ... };
         ```
       - Use a simple tier-to-credit lookup. Since switch expressions aren't Burst-safe, use if/else chain or a FixedList.
    3. Update DestructionEvent to include the asteroid's ResourceTier (already has a ResourceTier field, currently hardcoded 0)

    **FeedbackComponents.cs** -- Verify DestructionEvent.ResourceTier field exists (it does). No changes needed, but verify MineralSpawnSystem sets it correctly.

    **PlayingState.cs** -- Apply level config at run start:
    - In Enter() (or wherever the run starts), read RunConfigData.CurrentLevel from ECS
    - Write the corresponding level's drop table weights into RunConfigData.TierWeight0..5
    - Write HP multiplier, spawn interval, max asteroids overrides into RunConfigData
    - This ensures each run uses the correct level configuration
    - The actual level config data comes from LevelConfigDefinitions.GetLevelConfig(level)

    Actually, better approach: Have PlayingState.Enter read RunConfigData.CurrentLevel and apply the level config values. Since PlayingState is a MonoBehaviour/state, it has full managed access. It writes RunConfigData via EntityManager. This follows the existing pattern where PlayingState reads/writes ECS state at run boundaries.

    **MineralRenderer.cs** -- Per-tier mineral colors:
    1. When configuring mineral visuals (ConfigureMineralVisual), read the entity's MineralData.ResourceTier
    2. Look up color and emissive intensity from ResourceTierDefinitions.GetTier(tier)
    3. Apply the tier-specific color and emissive to the MaterialPropertyBlock
    4. Apply tier-specific trail color
    5. Modify the LateUpdate entity sync to pass the tier: when assigning a new pooled GO to a newly discovered entity, read MineralData.ResourceTier and use that for visual config
    6. This requires reading MineralData from the entity in LateUpdate. Add MineralData to the entity query:
       ```
       mineralQuery = em.CreateEntityQuery(typeof(MineralTag), typeof(LocalTransform), typeof(MineralData));
       ```
       Then in the sync loop, after getting the entity: `var mineralData = em.GetComponentData<MineralData>(entity);`
    7. Cache the tier per entity so you don't reconfigure every frame -- only configure on first assignment (already the pattern: config happens in the `!entityToGo.TryGetValue` branch)

    **Asteroid size scaling by HP (locked decision: larger = tougher, no color tinting):**
    - This is handled in the AsteroidRenderer (which uses the same Dictionary<Entity, GameObject> pattern)
    - Read HealthData.MaxHP when assigning a pooled GO to a new asteroid entity
    - Scale = baseScale * (MaxHP / DefaultAsteroidHP)^0.33 (cube root so doubling HP only increases size by ~26%)
    - Or simpler: scale = 1.0 + (MaxHP / DefaultAsteroidHP - 1.0) * 0.3 (linear scaling, 30% of the HP increase maps to size)
    - Find and modify the AsteroidRenderer file to read HealthData on entity creation and set transform.localScale

    Find AsteroidRenderer location:
    - Should be in Assets/Scripts/MonoBehaviours/Rendering/ (based on existing pattern). Read it and add HP-based size scaling in the entity setup code. The asteroid prefab scale base is likely 1.0.
  </action>
  <verify>
    Project compiles without errors. Verify:
    - AsteroidComponents.cs has AsteroidResourceTier component
    - AsteroidSpawnSystem reads RunConfigData and picks resource tier via weighted random
    - AsteroidSpawnSystem sets HP based on level multiplier
    - MineralSpawnSystem reads asteroid tier, sets mineral credit value and resource tier
    - MineralRenderer applies per-tier colors
    - LevelConfigDefinitions has 5 level configs with correct drop tables
    - ResourceTierDefinitions has 6 tiers with correct colors matching locked decisions
    - PlayingState applies level config to RunConfigData at run start
  </verify>
  <done>
    Asteroids spawn with resource tiers based on current level's drop table. Higher-level asteroids have more HP and are visually larger. Minerals inherit their asteroid's resource tier and display the correct tier color (grey/orange/white/blue/yellow/purple). Mineral credit values scale with tier rarity. Level configs define 5 distinct levels with progressively rarer drop tables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate economy bonuses (ResourceMultiplier, LuckyStrike) and RunConfigData into gameplay systems</name>
  <files>
    Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs
    Assets/Scripts/ECS/Components/EconomyComponents.cs
    Assets/Scripts/States/PlayingState.cs
  </files>
  <action>
    **MineralCollectionSystem.cs** -- Apply economy bonuses on mineral collection:
    1. Add `state.RequireForUpdate<PlayerBonusData>();` in OnCreate
    2. In OnUpdate, read PlayerBonusData singleton:
       ```
       var bonus = SystemAPI.GetSingleton<PlayerBonusData>();
       ```
    3. Modify credit calculation to apply ResourceMultiplier:
       ```
       int baseCredits = mineralData.ValueRO.CreditValue;
       int finalCredits = (int)(baseCredits * bonus.ResourceMultiplier);
       ```
    4. Apply Lucky Strike: roll a random chance for double credits:
       - Need an RNG in this system. Add `private Random rng;` field and seed in OnCreate with a unique seed
       - ```
         if (bonus.LuckyStrikeChance > 0f && rng.NextFloat(0f, 1f) < bonus.LuckyStrikeChance)
         {
             finalCredits *= 2;
             // Optionally set a flag on the CollectionEvent for the UI to show "LUCKY!" text
         }
         ```
    5. Replace `gameStateRW.ValueRW.Credits += mineralData.ValueRO.CreditValue;` with:
       ```
       gameStateRW.ValueRW.Credits += finalCredits;
       ```
    6. Update CollectionEvent.CreditValue to use finalCredits (so the damage popup and SFX reflect the actual amount)

    **PlayingState.cs** -- Read RunConfigData for run duration:
    - Currently PlayingState sets `gameState.Timer = GameConstants.DefaultRunDuration` in Enter()
    - Change to read from RunConfigData singleton:
      ```
      var runConfigQuery = em.CreateEntityQuery(typeof(RunConfigData));
      if (runConfigQuery.CalculateEntityCount() > 0)
      {
          var runConfig = runConfigQuery.GetSingleton<RunConfigData>();
          gameState.Timer = runConfig.RunDuration;
      }
      else
      {
          gameState.Timer = GameConstants.DefaultRunDuration; // Fallback
      }
      ```
    - Also apply level config at run start: after reading RunConfigData.CurrentLevel, call LevelConfigDefinitions.GetLevelConfig(level) and write the level's drop table weights, HP multiplier, spawn interval, and max asteroids into RunConfigData:
      ```
      var levelConfig = LevelConfigDefinitions.GetLevelConfig(runConfig.CurrentLevel);
      runConfig.AsteroidHPMultiplier = levelConfig.AsteroidHPMultiplier;
      if (levelConfig.SpawnIntervalOverride > 0)
          runConfig.SpawnInterval = levelConfig.SpawnIntervalOverride;
      if (levelConfig.MaxActiveAsteroidsOverride > 0)
          runConfig.MaxActiveAsteroids = levelConfig.MaxActiveAsteroidsOverride;
      // Write tier weights from level config drop table
      runConfig.TierWeight0 = 0; runConfig.TierWeight1 = 0; ... // Reset all
      foreach (var tw in levelConfig.DropTable)
          // Set the corresponding TierWeightN field based on tw.TierIndex
      em.SetComponentData(runConfigEntity, runConfig);
      ```
    - This ensures that every run starts with the correct level configuration applied to the ECS singletons

    **Also update the AsteroidSpawnTimer at run start:**
    - In PlayingState.Enter() or GameManager.ResetRun(), sync AsteroidSpawnTimer with RunConfigData values:
      ```
      var spawnTimer = em.GetComponentData<AsteroidSpawnTimer>(spawnTimerEntity);
      spawnTimer.SpawnInterval = runConfig.SpawnInterval;
      spawnTimer.MaxActiveAsteroids = runConfig.MaxActiveAsteroids;
      em.SetComponentData(spawnTimerEntity, spawnTimer);
      ```
    - This bridges the RunConfigData (modified by tech tree) to the AsteroidSpawnTimer (read by AsteroidSpawnSystem in its existing code). This way AsteroidSpawnSystem needs minimal changes -- it keeps reading from AsteroidSpawnTimer as before.

    **IMPORTANT:** With this approach, AsteroidSpawnSystem changes from Task 1 can be simplified:
    - AsteroidSpawnSystem still reads AsteroidSpawnTimer for interval/max (already does)
    - AsteroidSpawnSystem reads RunConfigData ONLY for tier weights and HP multiplier
    - PlayingState.Enter() syncs RunConfigData -> AsteroidSpawnTimer at run start
    - This minimizes changes to the hot-path Burst system

    **RunConfigData field additions** (if not already in 06-01):
    - Ensure RunConfigData in EconomyComponents.cs has the TierWeight0..5 fields
    - If 06-01 didn't add these, add them now (they're needed for the Burst-accessible weighted random in AsteroidSpawnSystem)
  </action>
  <verify>
    Project compiles without errors. Verify:
    - MineralCollectionSystem applies ResourceMultiplier to credit awards
    - MineralCollectionSystem rolls LuckyStrike chance for double credits
    - PlayingState reads RunConfigData.RunDuration for timer instead of GameConstants
    - PlayingState applies level config (drop table, HP mult, spawn settings) to ECS singletons at run start
    - AsteroidSpawnTimer synced from RunConfigData values at run start
  </verify>
  <done>
    Economy bonuses (ResourceMultiplier, LuckyStrike) actively modify credit earnings during gameplay. Run duration reads from the tech-tree-modifiable RunConfigData singleton. Level configurations are applied to all relevant ECS singletons at the start of each run, ensuring asteroids spawn with correct HP, tier distribution, and spawn rates for the current level. The complete level progression and economy systems are integrated end-to-end.
  </done>
</task>

</tasks>

<verification>
1. Level 1 run spawns only Iron-tier asteroids (grey minerals, 10 credits each)
2. After purchasing Advance to Level 2, next run has Copper minerals (orange, 25 credits)
3. Asteroid HP increases with level (Level 3+ asteroids take noticeably more hits)
4. Higher-level asteroids are visually larger
5. ResourceMultiplier upgrade increases credit earnings per mineral
6. LuckyStrike upgrade occasionally doubles mineral credit value
7. Run time extension upgrades make runs last longer
8. All 6 mineral tier colors are visually distinct against the dark space background
9. Credits per run scale meaningfully with level (higher levels earn more)
</verification>

<success_criteria>
- 5 levels with distinct drop tables rendering correct mineral colors
- Asteroid HP scales with level, size scales with HP
- 6 resource tiers with distinct colors: grey, orange, white, blue, yellow, purple
- Economy bonuses apply during collection (ResourceMultiplier, LuckyStrike)
- Run duration reads from RunConfigData (modified by tech tree)
- Level config applies correctly at each run start
- Backward compatible: Level 1 gameplay unchanged from Phase 5
</success_criteria>

<output>
After completion, create `.planning/phases/06-tech-tree-and-level-progression/06-03-SUMMARY.md`
</output>
