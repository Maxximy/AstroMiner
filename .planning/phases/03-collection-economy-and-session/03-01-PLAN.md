---
phase: 03-collection-economy-and-session
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Assets/Scripts/ECS/Components/MineralComponents.cs
  - Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs
  - Assets/Scripts/ECS/Systems/MineralPullSystem.cs
  - Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs
  - Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs
  - Assets/Scripts/Data/ResourceTierSO.cs
  - Assets/Scripts/Shared/GameConstants.cs
  - Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
autonomous: true
requirements: [MINR-01, MINR-02, MINR-03, MINR-04, ECON-01, ECON-04]

must_haves:
  truths:
    - "Destroyed asteroids release mineral particles at their position"
    - "Mineral particles accelerate toward the ship and are collected on contact"
    - "Collected minerals award credits to GameStateData.Credits based on tier"
    - "Mineral particles are visible as small colored spheres synced from ECS"
  artifacts:
    - path: "Assets/Scripts/ECS/Components/MineralComponents.cs"
      provides: "MineralTag, MineralData, MineralPullData, CollectionEvent"
      contains: "IComponentData"
    - path: "Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs"
      provides: "Spawns mineral entities when asteroids die"
      contains: "UpdateBefore"
    - path: "Assets/Scripts/ECS/Systems/MineralPullSystem.cs"
      provides: "Accelerates minerals toward ship"
      contains: "IJobEntity"
    - path: "Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs"
      provides: "Collects minerals near ship, awards credits"
      contains: "CollectionEvent"
    - path: "Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs"
      provides: "ECS-to-pooled-GameObject sync for minerals"
      contains: "GameObjectPool"
    - path: "Assets/Scripts/Data/ResourceTierSO.cs"
      provides: "ScriptableObject for resource tier config"
      contains: "CreateAssetMenu"
    - path: "Assets/Scripts/Shared/GameConstants.cs"
      provides: "Mineral physics and session constants"
      contains: "MineralInitialSpeed"
  key_links:
    - from: "Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs"
      to: "Assets/Scripts/ECS/Systems/AsteroidDestructionSystem.cs"
      via: "UpdateBefore ordering ensures minerals spawn before asteroid entity destroyed"
      pattern: "UpdateBefore.*AsteroidDestructionSystem"
    - from: "Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs"
      to: "Assets/Scripts/ECS/Components/GameStateComponents.cs"
      via: "Increments GameStateData.Credits on collection"
      pattern: "Credits.*CreditValue"
    - from: "Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs"
      to: "Assets/Scripts/ECS/Components/MineralComponents.cs"
      via: "EntityQuery on MineralTag + LocalTransform, syncs to pooled GameObjects"
      pattern: "MineralTag"
---

<objective>
Mineral ECS lifecycle: spawn from destroyed asteroids, pull toward ship, collect on contact, award credits, render via pooled GameObjects.

Purpose: This is the first half of closing the core game loop -- asteroids now produce something valuable when destroyed, giving the player a reason to mine.

Output: MineralComponents, 3 ECS systems (spawn, pull, collection), MineralRenderer, ResourceTierSO, extended GameConstants, CollectionEvent buffer in ECSBootstrap.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-collection-economy-and-session/03-RESEARCH.md

@Assets/Scripts/Shared/GameConstants.cs
@Assets/Scripts/ECS/Components/AsteroidComponents.cs
@Assets/Scripts/ECS/Systems/AsteroidDestructionSystem.cs
@Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs
@Assets/Scripts/MonoBehaviours/Core/AsteroidRenderer.cs
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
@Assets/Scripts/ECS/Components/GameStateComponents.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mineral ECS components, constants, ResourceTierSO, and 3 mineral systems</name>
  <files>
    Assets/Scripts/ECS/Components/MineralComponents.cs
    Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs
    Assets/Scripts/ECS/Systems/MineralPullSystem.cs
    Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs
    Assets/Scripts/Data/ResourceTierSO.cs
    Assets/Scripts/Shared/GameConstants.cs
    Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
  </files>
  <action>
    **MineralComponents.cs** -- Create 4 unmanaged IComponentData structs plus 1 IBufferElementData:
    - `MineralTag : IComponentData` -- empty tag for EntityQuery filtering
    - `MineralData : IComponentData` -- `int ResourceTier`, `int CreditValue`
    - `MineralPullData : IComponentData` -- `float CurrentSpeed`, `float Acceleration`
    - `CollectionEvent : IBufferElementData` -- `int ResourceTier`, `int CreditValue`, `float3 Position` (for future SFX/VFX in Phase 4)

    **ResourceTierSO.cs** -- ScriptableObject with `[CreateAssetMenu(fileName = "NewResourceTier", menuName = "AstroMiner/Resource Tier")]`:
    - Fields: `string TierName`, `int TierIndex`, `int CreditValue`, `int MineralsPerAsteroid`, `Color MineralColor`, `[Range(0f, 4f)] float EmissiveIntensity`
    - This defines the data model for Phase 6; Phase 3 uses GameConstants defaults for the single Iron tier.

    **GameConstants.cs** -- Add new constants block for minerals and session:
    - `MinMineralsPerAsteroid = 3`, `MaxMineralsPerAsteroid = 8`
    - `DefaultCreditValuePerMineral = 10`
    - `MineralInitialSpeed = 1f`, `MineralAcceleration = 3f`
    - `MineralCollectionRadius = 0.8f` (distance from ship center to collect)
    - `MineralScale = 0.3f` (visual size of mineral GameObjects)
    - `DefaultRunDuration = 60f` (seconds per timed run -- consumed by Plan 03-02)
    - `CollectingGracePeriod = 2f` (consumed by Plan 03-02)
    - `ShipPositionX = 0f` (ship X coordinate for pull target, complements existing ShipPositionZ)

    **MineralSpawnSystem.cs** -- Burst-compiled ISystem:
    - `[BurstCompile]` on struct and OnUpdate. Do NOT put [BurstCompile] on OnCreate.
    - `[UpdateBefore(typeof(AsteroidDestructionSystem))]` -- CRITICAL ordering: read asteroid position before it's destroyed.
    - OnCreate: seed `Unity.Mathematics.Random` with `(uint)System.Environment.TickCount | 1u`, call `state.RequireForUpdate<GameStateData>()`.
    - OnUpdate: guard on `gameState.Phase == GamePhase.Playing || gameState.Phase == GamePhase.Collecting` (asteroids hit 0HP during either phase).
    - Iterate `SystemAPI.Query<RefRO<HealthData>, RefRO<LocalTransform>>().WithAll<AsteroidTag>().WithEntityAccess()`.
    - When `CurrentHP <= 0f`: spawn `_rng.NextInt(GameConstants.MinMineralsPerAsteroid, GameConstants.MaxMineralsPerAsteroid + 1)` mineral entities.
    - Each mineral entity gets: `MineralTag`, `MineralData { ResourceTier = 0, CreditValue = GameConstants.DefaultCreditValuePerMineral }`, `MineralPullData { CurrentSpeed = GameConstants.MineralInitialSpeed, Acceleration = GameConstants.MineralAcceleration }`, `LocalTransform.FromPosition(asteroidPos + randomXZOffset)`, `LocalToWorld`.
    - Random offset: `_rng.NextFloat2(new float2(-0.5f), new float2(0.5f))` applied to X and Z.
    - Use `EndSimulationEntityCommandBufferSystem.Singleton` for ECB (same as AsteroidSpawnSystem).

    **MineralPullSystem.cs** -- Burst-compiled ISystem with IJobEntity:
    - `[BurstCompile]` on struct and OnUpdate. NOT on OnCreate.
    - OnCreate: `state.RequireForUpdate<GameStateData>()`.
    - OnUpdate: guard on `Phase == GamePhase.Playing || Phase == GamePhase.Collecting` (minerals fly during both).
    - Schedule `MineralPullJob` with `DeltaTime = SystemAPI.Time.DeltaTime`, `ShipPosition = new float3(GameConstants.ShipPositionX, 0f, GameConstants.ShipPositionZ)`.
    - `MineralPullJob : IJobEntity` with `[BurstCompile]` and `[WithAll(typeof(MineralTag))]`:
      - `Execute(ref LocalTransform transform, ref MineralPullData pull)` -- compute direction toward ShipPosition, normalize, accelerate `pull.CurrentSpeed += pull.Acceleration * DeltaTime`, move `transform.Position += normalizedDir * pull.CurrentSpeed * DeltaTime`. Guard against zero-distance division (`dist > 0.01f`).

    **MineralCollectionSystem.cs** -- Burst-compiled ISystem:
    - `[BurstCompile]` on struct and OnUpdate. NOT on OnCreate.
    - `[UpdateAfter(typeof(MineralPullSystem))]` -- collect after movement is applied.
    - OnCreate: `state.RequireForUpdate<GameStateData>()`.
    - OnUpdate: guard on `Phase == GamePhase.Playing || Phase == GamePhase.Collecting`.
    - Get ECB from `EndSimulationEntityCommandBufferSystem.Singleton`.
    - Get `GameStateData` via `SystemAPI.GetSingletonRW<GameStateData>()` to increment credits.
    - Iterate `SystemAPI.Query<RefRO<MineralData>, RefRO<LocalTransform>>().WithAll<MineralTag>().WithEntityAccess()`.
    - When `math.distance(mineralPos, shipPos) <= GameConstants.MineralCollectionRadius`: add `MineralData.CreditValue` to `gameStateRW.ValueRW.Credits`, destroy entity via ECB.
    - NOTE: Cannot write CollectionEvent buffer from a Burst-compiled ISystem because DynamicBuffer is managed. Instead, directly increment `GameStateData.Credits` in the system. The HUD will read the singleton directly. DynamicBuffer events for SFX/VFX will be added in Phase 4 when AudioEventBridge exists.

    **ECSBootstrap.cs** -- Add after the MiningConfigData singleton creation:
    - Create a CollectionEvent buffer entity: `var collectionEventEntity = em.CreateEntity(); em.AddBuffer<CollectionEvent>(collectionEventEntity);`
    - This buffer entity exists for Phase 4 to write/drain audio events; for now it establishes the infrastructure.
    - Update the debug log to include the new singleton.
  </action>
  <verify>
    All 7 files exist on disk. Grep confirms:
    - `MineralComponents.cs` contains `MineralTag`, `MineralData`, `MineralPullData`, `CollectionEvent`
    - `MineralSpawnSystem.cs` contains `UpdateBefore(typeof(AsteroidDestructionSystem))`
    - `MineralPullSystem.cs` contains `IJobEntity` and `WithAll(typeof(MineralTag))`
    - `MineralCollectionSystem.cs` contains `MineralCollectionRadius` and `DestroyEntity`
    - `GameConstants.cs` contains `MineralInitialSpeed` and `DefaultRunDuration`
    - `ECSBootstrap.cs` contains `AddBuffer<CollectionEvent>`
  </verify>
  <done>
    Mineral ECS pipeline is complete: MineralSpawnSystem creates minerals from dead asteroids, MineralPullSystem moves them toward the ship, MineralCollectionSystem awards credits and destroys them on contact. ResourceTierSO defines the data model for future tiers. GameConstants has all mineral physics and session timing values.
  </done>
</task>

<task type="auto">
  <name>Task 2: MineralRenderer with pooled GameObjects and tier-based coloring</name>
  <files>
    Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs
  </files>
  <action>
    **MineralRenderer.cs** -- MonoBehaviour that mirrors AsteroidRenderer pattern exactly:
    - Private fields: `EntityManager _em`, `EntityQuery _mineralQuery`, `bool _initialized`, `Dictionary<Entity, GameObject> _entityToGO`, `List<Entity> _entitiesToRemove`, `GameObjectPool _mineralPool`, `GameObject _mineralPrefab`.
    - `Start()`: call `StartCoroutine(InitializeNextFrame())` (same pattern as AsteroidRenderer for ECS singleton readiness).
    - `InitializeNextFrame()`: wait one frame, get world + EntityManager, create EntityQuery for `MineralTag` + `LocalTransform`, create mineral prefab (smaller sphere: `PrimitiveType.Sphere`, destroy collider, set inactive, parent to this transform), create pool with pre-warm count of 200 and max of 1200 (for 1000+ minerals), seed RNG.
    - `LateUpdate()`: if not initialized, return. Query all mineral entities. For each:
      - If new (not in dictionary): `_mineralPool.Get()`, configure visual (scale to `GameConstants.MineralScale` uniformly, set `_BaseColor` via MaterialPropertyBlock to a default mineral color -- use a soft gold/amber `new Color(0.9f, 0.75f, 0.3f)` for Iron tier).
      - Sync `LocalTransform` position to `GameObject.transform.position`.
    - Cleanup pass: iterate dictionary, release any GameObjects whose entity is no longer in the active set (same HashSet pattern as AsteroidRenderer).
    - `OnDestroy()`: destroy the prefab template.

    The renderer follows AsteroidRenderer's exact structure for consistency. The mineral color is a warm gold/amber to visually distinguish from the dark gray/brown/rust asteroids. Phase 6 will read ResourceTierSO colors; Phase 3 uses a hardcoded default.

    NOTE: This MonoBehaviour will need to be added to a GameObject in the scene. The executor should note this in the summary as "User Setup Required" for CoPlay MCP or manual addition.
  </action>
  <verify>
    `MineralRenderer.cs` exists. Grep confirms it contains: `MineralTag`, `GameObjectPool`, `MaterialPropertyBlock`, `LateUpdate`, `Dictionary<Entity, GameObject>`.
  </verify>
  <done>
    Mineral particles are rendered as small gold spheres synced from ECS entities to pooled GameObjects, following the established AsteroidRenderer pattern. Pool supports 1000+ simultaneous minerals.
  </done>
</task>

</tasks>

<verification>
- MineralSpawnSystem runs before AsteroidDestructionSystem (UpdateBefore attribute present)
- MineralPullSystem uses IJobEntity with WithAll<MineralTag> for Burst-compiled processing
- MineralCollectionSystem increments GameStateData.Credits and destroys collected minerals
- MineralRenderer syncs ECS mineral entities to pooled GameObjects in LateUpdate
- All ECS systems guard on GamePhase.Playing or GamePhase.Collecting
- No [BurstCompile] on any OnCreate method
- CollectionEvent buffer entity created in ECSBootstrap
</verification>

<success_criteria>
When asteroids reach 0 HP, mineral particles spawn at their position, accelerate toward the ship, get collected on contact (awarding credits to GameStateData.Credits), and are rendered as small gold spheres. The mineral rendering scales to 1000+ simultaneous entities.
</success_criteria>

<output>
After completion, create `.planning/phases/03-collection-economy-and-session/03-01-SUMMARY.md`
</output>
