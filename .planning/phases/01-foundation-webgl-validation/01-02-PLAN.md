---
phase: 01-foundation-webgl-validation
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - Assets/Scripts/States/IGameState.cs
  - Assets/Scripts/States/PlayingState.cs
  - Assets/Scripts/States/CollectingState.cs
  - Assets/Scripts/States/GameOverState.cs
  - Assets/Scripts/States/UpgradingState.cs
  - Assets/Scripts/MonoBehaviours/Core/GameManager.cs
  - Assets/Scripts/MonoBehaviours/UI/FadeController.cs
  - Assets/Scripts/MonoBehaviours/UI/DebugOverlay.cs
  - Assets/Scripts/MonoBehaviours/Pool/GameObjectPool.cs
  - Assets/Scripts/MonoBehaviours/Core/PlaceholderSpawner.cs
  - Assets/Scripts/MonoBehaviours/Core/PlaceholderRenderer.cs
  - Assets/Scripts/ECS/Components/PlaceholderComponents.cs
  - Assets/Scripts/ECS/Systems/PlaceholderMovementSystem.cs
  - Assets/Scenes/Game.unity
autonomous: false
requirements:
  - INFRA-02
  - INFRA-03
  - INFRA-04

must_haves:
  truths:
    - "Game state machine transitions between Playing, Collecting, GameOver, and Upgrading states with smooth fade-to-black"
    - "Debug overlay shows current game state, FPS, and entity count in top-left corner"
    - "Object pool pre-allocates GameObjects and recycles them without runtime Instantiate/Destroy during gameplay"
    - "100 placeholder asteroids drift downward and spin, 1000 placeholder minerals drift, all driven by ECS systems"
    - "WebGL build loads and runs at 60 FPS with all 1100 placeholder entities active"
  artifacts:
    - path: "Assets/Scripts/MonoBehaviours/Core/GameManager.cs"
      provides: "Game state machine with FSM pattern, fade transitions, state registration"
      contains: "TransitionTo"
    - path: "Assets/Scripts/States/IGameState.cs"
      provides: "State interface with Enter/Execute/Exit"
      contains: "IGameState"
    - path: "Assets/Scripts/MonoBehaviours/Pool/GameObjectPool.cs"
      provides: "Object pool wrapper with pre-warming around Unity ObjectPool<T>"
      contains: "ObjectPool"
    - path: "Assets/Scripts/ECS/Systems/PlaceholderMovementSystem.cs"
      provides: "ECS system driving drift and spin for placeholder entities"
      contains: "IJobEntity"
    - path: "Assets/Scripts/MonoBehaviours/UI/DebugOverlay.cs"
      provides: "Debug UI showing state, FPS, entity count"
      contains: "FPS"
    - path: "Assets/Scripts/MonoBehaviours/UI/FadeController.cs"
      provides: "CanvasGroup-based fade-to-black transition controller"
      contains: "CanvasGroup"
  key_links:
    - from: "Assets/Scripts/MonoBehaviours/Core/GameManager.cs"
      to: "Assets/Scripts/ECS/Components/GameStateComponents.cs"
      via: "Writes GamePhase to ECS GameStateData singleton on state transition"
      pattern: "SetComponentData.*GameStateData"
    - from: "Assets/Scripts/MonoBehaviours/Core/GameManager.cs"
      to: "Assets/Scripts/States/IGameState.cs"
      via: "Holds dictionary of IGameState implementations, calls Enter/Execute/Exit"
      pattern: "Dictionary.*GamePhase.*IGameState"
    - from: "Assets/Scripts/ECS/Systems/PlaceholderMovementSystem.cs"
      to: "Assets/Scripts/ECS/Components/GameStateComponents.cs"
      via: "Reads GameStateData singleton to check if Phase is Playing before updating entities"
      pattern: "GetSingleton.*GameStateData"
    - from: "Assets/Scripts/MonoBehaviours/UI/DebugOverlay.cs"
      to: "Assets/Scripts/ECS/Components/GameStateComponents.cs"
      via: "Reads GameStateData to display current phase name"
      pattern: "GetSingleton.*GameStateData"
    - from: "Assets/Scripts/MonoBehaviours/Core/PlaceholderSpawner.cs"
      to: "Assets/Scripts/ECS/Components/PlaceholderComponents.cs"
      via: "Creates ECS entities with DriftData, SpinData, and PlaceholderTag components"
      pattern: "CreateEntity.*DriftData"
    - from: "Assets/Scripts/MonoBehaviours/Core/PlaceholderRenderer.cs"
      to: "Assets/Scripts/ECS/Components/PlaceholderComponents.cs"
      via: "Reads PlaceholderTag entities to sync ECS transforms to GameObjects"
      pattern: "PlaceholderTag"
---

<objective>
Implement the game state machine with fade transitions, object pooling system, placeholder entities with ECS-driven movement, debug overlay, and validate WebGL performance at target entity counts.

Purpose: Completes Phase 1 by proving the full hybrid architecture works end-to-end -- game states control flow, object pools eliminate runtime allocation, ECS systems drive 1100 entities, and a WebGL build confirms 60 FPS. This is the critical validation gate before any gameplay code is written.

Output: Working game state machine with 4 states and fade transitions, object pool with pre-warming, 100 drifting/spinning asteroid placeholders + 1000 mineral placeholders, debug overlay, and a WebGL build that hits 60 FPS.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-webgl-validation/01-RESEARCH.md
@.planning/phases/01-foundation-webgl-validation/01-CONTEXT.md
@.planning/phases/01-foundation-webgl-validation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Game state machine with fade transitions and debug overlay</name>
  <files>
    Assets/Scripts/States/IGameState.cs
    Assets/Scripts/States/PlayingState.cs
    Assets/Scripts/States/CollectingState.cs
    Assets/Scripts/States/GameOverState.cs
    Assets/Scripts/States/UpgradingState.cs
    Assets/Scripts/MonoBehaviours/Core/GameManager.cs
    Assets/Scripts/MonoBehaviours/UI/FadeController.cs
    Assets/Scripts/MonoBehaviours/UI/DebugOverlay.cs
    Assets/Scenes/Game.unity
  </files>
  <action>
**Step 1: Create Assets/Scripts/States/IGameState.cs**

Interface with three methods:
```csharp
public interface IGameState
{
    void Enter(GameManager manager);
    void Execute(GameManager manager);
    void Exit(GameManager manager);
}
```

**Step 2: Create four state implementations**

Each in its own file under `Assets/Scripts/States/`:

`PlayingState.cs`:
- Enter: Log "Entering Playing state". This is the active gameplay state.
- Execute: No-op for Phase 1 (gameplay systems not yet built).
- Exit: Log "Exiting Playing state".

`CollectingState.cs`:
- Enter: Log "Entering Collecting state". Per user decision, gameplay view stays visible -- no immediate fade.
- Execute: No-op for Phase 1. In future phases, this waits for minerals to fly to ship.
- Exit: Log "Exiting Collecting state".

`GameOverState.cs`:
- Enter: Log "Entering GameOver state".
- Execute: No-op for Phase 1.
- Exit: Log "Exiting GameOver state".

`UpgradingState.cs`:
- Enter: Log "Entering Upgrading state". Per user decision, this is a full-screen takeover (not overlay).
- Execute: No-op for Phase 1.
- Exit: Log "Exiting Upgrading state".

All states are stubs in Phase 1 -- they log transitions and will gain real behavior in later phases. The important thing is the FSM infrastructure works.

**Step 3: Create Assets/Scripts/MonoBehaviours/UI/FadeController.cs**

MonoBehaviour that manages fade-to-black transitions using a full-screen CanvasGroup:

Fields:
- `[SerializeField] CanvasGroup _fadeCanvasGroup` (full-screen black Image behind a CanvasGroup)
- `float _fadeDuration = 0.4f`

Public methods:
- `FadeOut(Action onComplete)` -- Animate alpha from 0 to 1 over `_fadeDuration` seconds using a coroutine with smooth ease-in-out (use `Mathf.SmoothStep`). Set `blocksRaycasts = true` at start. Call `onComplete` when done.
- `FadeIn(Action onComplete)` -- Animate alpha from 1 to 0. Set `blocksRaycasts = false` at end. Call `onComplete` when done.
- `SetBlack()` / `SetClear()` -- Immediate set for initialization.

Pitfall: When alpha is 0, set `blocksRaycasts = false` so invisible panel does not intercept clicks (see research Pitfall 5).

**Step 4: Create Assets/Scripts/MonoBehaviours/Core/GameManager.cs**

Singleton MonoBehaviour that owns the FSM:

Fields:
- `public static GameManager Instance { get; private set; }`
- `[SerializeField] FadeController _fadeController`
- `private IGameState _currentState`
- `private Dictionary<GamePhase, IGameState> _states`
- `private bool _isTransitioning` (prevent overlapping transitions)

In `Awake()`:
- Set `Instance = this`
- Initialize `_states` dictionary mapping all four GamePhase values to their IGameState implementations

In `Start()`:
- Set initial state to `PlayingState` by calling `TransitionTo(GamePhase.Playing)` (skip fade for initial state -- use immediate set)

`TransitionTo(GamePhase newPhase)`:
- Guard: if `_isTransitioning`, return (prevent double transitions)
- Set `_isTransitioning = true`
- Special case: Playing -> Collecting transition has NO fade (user decision: gameplay stays visible)
- Normal case: Call `_currentState.Exit(this)` -> `_fadeController.FadeOut` -> update ECS singleton -> set new state -> `_currentState.Enter(this)` -> `_fadeController.FadeIn` -> set `_isTransitioning = false`
- Write `newPhase` to ECS `GameStateData` singleton (same pattern as research Pattern 4):
  ```
  var em = World.DefaultGameObjectInjectionWorld.EntityManager;
  var query = em.CreateEntityQuery(typeof(GameStateData));
  var entity = query.GetSingletonEntity();
  var data = em.GetComponentData<GameStateData>(entity);
  data.Phase = newPhase;
  em.SetComponentData(entity, data);
  ```

For Phase 1 testing, add a temporary keyboard shortcut system in `Update()`:
- Press 1: TransitionTo(Playing)
- Press 2: TransitionTo(Collecting)
- Press 3: TransitionTo(GameOver)
- Press 4: TransitionTo(Upgrading)
This allows manual testing of all state transitions with fade. Mark with `// TODO: Remove in Phase 2 -- temporary testing shortcuts`

**Step 5: Create Assets/Scripts/MonoBehaviours/UI/DebugOverlay.cs**

MonoBehaviour that displays state, FPS, and entity count:

Fields:
- `[SerializeField] TextMeshProUGUI _stateText`
- `[SerializeField] TextMeshProUGUI _fpsText`
- `[SerializeField] TextMeshProUGUI _entityCountText`
- Private: `_fpsTimer`, `_frameCount`, cached `EntityManager`

In `Start()`:
- Cache `EntityManager` from `World.DefaultGameObjectInjectionWorld`

In `LateUpdate()`:
- FPS: Increment frame count, accumulate unscaled delta time. Every 0.5 seconds, calculate `_frameCount / _fpsTimer`, update text via `SetText("FPS: {0:0}", fps)`, reset counters.
- State: Read `GameStateData` singleton, display `Phase.ToString()`
- Entity count: Query entities with `LocalTransform` component, display `CalculateEntityCount()`

Use `TextMeshProUGUI.SetText()` with numeric overloads to avoid string allocation per frame.

**Step 6: Set up UI in Game scene**

Create the following UI hierarchy in the Game scene (use CoPlay MCP or document for manual setup):

1. **FadeCanvas** (Canvas, ScreenSpace-Overlay, Sort Order 100 -- always on top):
   - **FadePanel** (Image, black color, stretches to fill screen, CanvasGroup component)
   - Attach `FadeController` to FadeCanvas, reference FadePanel's CanvasGroup

2. **DebugCanvas** (Canvas, ScreenSpace-Overlay, Sort Order 99):
   - **DebugPanel** (top-left corner, 10px margin, semi-transparent black background alpha 0.6)
     - **StateText** (TextMeshProUGUI, 14pt)
     - **FPSText** (TextMeshProUGUI, 14pt)
     - **EntityCountText** (TextMeshProUGUI, 14pt)
   - Use Vertical Layout Group on DebugPanel for auto-stacking
   - Attach `DebugOverlay`, wire the three TextMeshProUGUI references

3. **GameManager** (empty GameObject):
   - Attach `GameManager` MonoBehaviour
   - Wire `FadeController` reference

User decisions honored: Debug UI in top-left corner, small and unobtrusive, visible in all states.
  </action>
  <verify>
Enter Play mode. Verify:
1. Game starts in Playing state -- DebugOverlay shows "Playing"
2. FPS counter updates every 0.5s in debug overlay
3. Entity count shows in debug overlay (should show 2 for the singletons from Plan 01-01)
4. Press 2 -- smooth fade to black, then "Collecting" appears in debug overlay, fade back in
5. Press 3 -- fade transition to GameOver
6. Press 4 -- fade transition to Upgrading
7. Press 1 -- back to Playing
8. Press 1 while already in Playing -- no transition (guard against same-state)
9. Rapidly press different numbers -- no errors, transitions don't overlap (isTransitioning guard)
10. Console shows Enter/Exit log messages for each state transition
11. No exceptions or errors in Console
  </verify>
  <done>
Game state machine transitions between all four states (Playing, Collecting, GameOver, Upgrading) with smooth 0.4s fade-to-black. Playing->Collecting has no fade (per user decision). Debug overlay in top-left shows current state name, FPS counter, and entity count. FadeController properly handles blocksRaycasts. ECS GameStateData singleton is updated on every transition.
  </done>
</task>

<task type="auto">
  <name>Task 2: Object pool, placeholder entities with ECS movement, and WebGL benchmark</name>
  <files>
    Assets/Scripts/MonoBehaviours/Pool/GameObjectPool.cs
    Assets/Scripts/ECS/Components/PlaceholderComponents.cs
    Assets/Scripts/ECS/Systems/PlaceholderMovementSystem.cs
    Assets/Scenes/Game.unity
  </files>
  <action>
**Step 1: Create Assets/Scripts/MonoBehaviours/Pool/GameObjectPool.cs**

Wrapper around Unity's built-in `ObjectPool<T>` from `UnityEngine.Pool` with pre-warming:

Constructor parameters: `GameObject prefab`, `Transform parent`, `int preWarmCount`, `int maxSize`

Internal `ObjectPool<GameObject>` with callbacks:
- createFunc: `Object.Instantiate(prefab, parent)`
- actionOnGet: `obj.SetActive(true)`
- actionOnRelease: `obj.SetActive(false)`
- actionOnDestroy: `Object.Destroy(obj)`
- collectionCheck: true (catches double-release bugs)
- defaultCapacity: preWarmCount
- maxSize: maxSize

Pre-warming: After construction, loop `preWarmCount` times calling `Get()` into a temporary array, then `Release()` each back. This is critical -- `defaultCapacity` does NOT pre-allocate objects (see research Pitfall 4).

Public API:
- `Get()` -> returns active GameObject
- `Release(GameObject obj)` -> returns to pool
- `CountActive` -> number currently in use
- `CountInactive` -> number available in pool

See research Pattern 5 for exact implementation.

**Step 2: Create Assets/Scripts/ECS/Components/PlaceholderComponents.cs**

ECS component structs for placeholder entity movement:

`DriftData : IComponentData` with:
- `float Speed` (units per second, downward drift)

`SpinData : IComponentData` with:
- `float RadiansPerSecond` (rotation speed)

`PlaceholderTag : IComponentData` -- empty tag to identify placeholder entities for cleanup.

**Step 3: Create Assets/Scripts/ECS/Systems/PlaceholderMovementSystem.cs**

Unmanaged ISystem with BurstCompile that drives placeholder entity movement:

Contains two IJobEntity jobs:

`PlaceholderDriftJob : IJobEntity`:
- Field: `float DeltaTime`
- Execute: `ref LocalTransform transform, in DriftData drift`
- Logic: `transform.Position.y -= drift.Speed * DeltaTime`

`PlaceholderSpinJob : IJobEntity`:
- Field: `float DeltaTime`
- Execute: `ref LocalTransform transform, in SpinData spin`
- Logic: `transform = transform.RotateY(spin.RadiansPerSecond * DeltaTime)`

`PlaceholderMovementSystem : ISystem`:
- Attribute: `[BurstCompile]` (runs as managed fallback on WebGL, native on desktop -- same code)
- `OnUpdate`: Check `GameStateData.Phase == GamePhase.Playing` -- only move entities during Playing state. Schedule both jobs via `ScheduleParallel()`.

See research Pattern 3 for exact code structure.

**Step 4: Create placeholder entity spawner**

Create a MonoBehaviour `PlaceholderSpawner.cs` (in `Assets/Scripts/MonoBehaviours/Core/`) that spawns placeholder entities on Start:

In `Start()` (after ECSBootstrap has run -- use script execution order or a 1-frame delay via coroutine):
1. Get `EntityManager` from `World.DefaultGameObjectInjectionWorld`
2. Create an asteroid archetype: `LocalTransform, DriftData, SpinData, PlaceholderTag`
3. Create a mineral archetype: `LocalTransform, DriftData, PlaceholderTag`
4. Spawn 100 asteroid entities spread across the play area:
   - Random X position within camera view bounds
   - Random Y position across the vertical space (top 85% of screen area)
   - DriftData.Speed: random 0.5-2.0
   - SpinData.RadiansPerSecond: random 0.5-3.0
5. Spawn 1000 mineral entities:
   - Random positions spread across the play area
   - DriftData.Speed: random 0.3-1.0 (slower than asteroids)
   - No spin data for minerals

Use `EntityManager.CreateEntity(archetype)` in a loop. This is initialization code (runs once at startup), so sync points from direct EntityManager calls are acceptable here. Use `EntityCommandBuffer` if creating entities during gameplay.

**Step 5: Create placeholder GameObject representations**

For the Phase 1 benchmark, we need visible GameObjects to represent ECS entities. Create a simple `PlaceholderRenderer.cs` MonoBehaviour that:

Option A (simpler, recommended for Phase 1): Create GameObjects for each ECS entity and sync their transforms each frame. Use a MonoBehaviour system that:
1. On Start, pre-creates 100 asteroid GameObjects (Unity sphere primitives, scale ~1.0-1.5, colors from warm muted palette: dark gray #555555, brown #8B6914, rust #B7410E) and 1000 mineral GameObjects (Unity cube primitives, scale ~0.15-0.25, colors: cyan, green, gold, purple)
2. Uses the GameObjectPool for creation (pre-warm all 1100 objects)
3. Each frame in LateUpdate, iterates ECS entities with `PlaceholderTag` and syncs their `LocalTransform.Position` and `LocalTransform.Rotation` to the corresponding GameObject transforms

For the sync, use a managed SystemBase (not ISystem) that reads ECS entity data and updates GameObjects. Store a mapping of Entity -> GameObject using a Dictionary or NativeHashMap.

The placeholder visuals per user decisions:
- Asteroids: spheres, randomly colored from dark gray/brown/rust palette
- Minerals: tiny cubes, randomly colored cyan/green/gold/purple
- Ship: basic triangle or arrow shape at bottom center (static, no ECS entity needed -- just a GameObject)

Create a simple ship placeholder GameObject: a flattened cube scaled to (1, 0.1, 0.5) or a rotated diamond shape, light gray color, positioned at the bottom 10% of the camera view.

**Step 6: Log entity count and frame timing**

Add a `Debug.Log($"Spawned {asteroidCount} asteroids + {mineralCount} minerals. Total entities: {totalCount}")` after spawning completes. In the PlaceholderMovementSystem, add a one-time log of frame time on the first Update after spawning to get an early performance signal.
  </action>
  <verify>
Enter Play mode. Verify:
1. 100 sphere-like asteroids visible in the play area, slowly drifting downward and spinning
2. 1000 tiny cube minerals visible, drifting downward
3. Ship placeholder visible at bottom of screen
4. All objects move smoothly (drift + spin driven by ECS systems)
5. Debug overlay shows "Entities: 1102" (or close -- 1100 placeholder + 2 singletons)
6. Debug overlay FPS shows 60+ on desktop
7. Press 2 (Collecting) -- entities stop moving (system checks GamePhase)
8. Press 1 (Playing) -- entities resume moving
9. Console shows spawn count log message
10. No frame spikes after initial spawn (objects pre-warmed from pool)
11. No Instantiate/Destroy calls during gameplay (only during initialization)
  </verify>
  <done>
Object pool pre-warms 1100 GameObjects (100 asteroids + 1000 minerals) without runtime instantiation. ECS PlaceholderMovementSystem drives drift and spin for all entities. Placeholder asteroids (colored spheres), minerals (colored cubes), and ship (gray shape at bottom) are visible. Entities only move during Playing state. Debug overlay confirms entity count ~1100 and FPS 60+ on desktop. Pool infrastructure established for INFRA-03; damage popup and particle pools deferred to phases where those objects are introduced (Phase 4).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: WebGL build and 60 FPS validation</name>
  <files>Assets/Scenes/Game.unity</files>
  <action>
Build and verify the complete Phase 1 foundation on both desktop and WebGL.

What was built: ECS world with 1100 placeholder entities (100 asteroids + 1000 minerals) driven by ECS drift/spin systems, game state machine with 4 states and fade transitions, object pooling with pre-warming, InputBridge writing mouse position to ECS, debug overlay, starfield skybox, and URP bloom + tonemapping.

**Desktop verification (in Unity Editor):**
1. Enter Play mode in Game scene
2. Confirm debug overlay shows: State "Playing", FPS 60+, Entities ~1100
3. Move mouse -- no errors, InputBridge running
4. Press 1/2/3/4 to cycle through states -- smooth fade transitions, debug overlay updates
5. Entities drift and spin during Playing, stop during other states
6. Skybox visible as dark space background
7. Bloom visible (subtle glow on any bright objects)

**WebGL verification:**
1. Build WebGL: File > Build Settings > WebGL > Build
   - Compression: Brotli
   - Enable WebAssembly 2023 in Player Settings if available
   - Exception Handling: Explicitly Thrown Exceptions Only
2. Serve the build locally (e.g., `npx serve Build/` or Unity's built-in server)
3. Open in Chrome
4. Confirm: Scene loads without errors in browser console
5. Confirm: Debug overlay shows FPS 60+ (or note the actual FPS)
6. Confirm: All 1100 entities visible and moving
7. Confirm: State transitions work (keyboard 1-4)
8. Confirm: Skybox and post-processing render correctly

**CRITICAL:** The WebGL FPS number is the Phase 1 validation gate. If it is below 60 FPS, note the actual FPS so we can decide whether to reduce entity counts or optimize before Phase 2.
  </action>
  <verify>
User performs the desktop and WebGL verification steps above and reports the WebGL FPS number. Type "approved [WebGL FPS]" or describe issues found.
  </verify>
  <done>
WebGL build loads without errors, runs at 60 FPS with 1100 placeholder entities, all Phase 1 features functional on both desktop and WebGL.
  </done>
</task>

</tasks>

<verification>
1. Game state machine: All four states reachable via keyboard shortcuts, smooth fade transitions, ECS singleton updated
2. Debug overlay: Shows current state, FPS (updated every 0.5s), entity count (~1102)
3. Object pool: 1100 GameObjects pre-warmed at startup, no Instantiate/Destroy during Play mode
4. ECS systems: PlaceholderMovementSystem drives drift + spin, respects GamePhase (stops when not Playing)
5. InputBridge: Mouse position continuously updated in ECS InputData singleton
6. Visuals: Starfield skybox, bloom on emissive objects, perspective top-down camera
7. WebGL: Build loads, runs at 60 FPS (critical gate), all features functional
</verification>

<success_criteria>
- Game state machine transitions between Playing/Collecting/GameOver/Upgrading with 0.4s fade (Playing->Collecting has no fade)
- Debug overlay in top-left corner shows state, FPS, entity count
- Object pool pre-allocates 1100 GameObjects; zero runtime Instantiate during gameplay
- 100 asteroid placeholders drift and spin, 1000 mineral placeholders drift -- all ECS-driven
- Ship placeholder visible at bottom 10% of screen
- WebGL build loads and runs at 60 FPS with 1100 entities (THE critical validation gate)
- No compile errors, no runtime errors on desktop or WebGL
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-webgl-validation/01-02-SUMMARY.md`
</output>
