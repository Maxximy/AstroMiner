---
phase: 03-collection-economy-and-session
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - Assets/Scripts/States/PlayingState.cs
  - Assets/Scripts/States/CollectingState.cs
  - Assets/Scripts/States/GameOverState.cs
  - Assets/Scripts/States/UpgradingState.cs
  - Assets/Scripts/MonoBehaviours/UI/HUDController.cs
  - Assets/Scripts/MonoBehaviours/UI/ResultsScreen.cs
  - Assets/Scripts/MonoBehaviours/UI/UpgradeScreen.cs
  - Assets/Scripts/MonoBehaviours/Core/UISetup.cs
  - Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
  - Assets/Scripts/MonoBehaviours/Core/GameManager.cs
autonomous: true
requirements: [ECON-02, ECON-03, SESS-01, SESS-02, SESS-03, SESS-04, SESS-05, SESS-06]

must_haves:
  truths:
    - "Running credit total is displayed during gameplay formatted with K/M/B/T suffixes"
    - "Visible countdown timer counts down from 60 seconds during Playing phase"
    - "When timer hits 0, mining stops but minerals still fly to ship (Collecting phase)"
    - "When all minerals and asteroids are gone, results screen shows credits earned this run"
    - "Player can proceed from results to upgrade screen and start a new run"
    - "Credits accumulate across multiple runs within a session (timer resets, credits do not); cross-session persistence completed by 03-03"
  artifacts:
    - path: "Assets/Scripts/MonoBehaviours/UI/HUDController.cs"
      provides: "Credits and timer display during gameplay"
      contains: "NumberFormatter"
    - path: "Assets/Scripts/MonoBehaviours/UI/ResultsScreen.cs"
      provides: "Run results with credits earned and continue button"
      contains: "Continue"
    - path: "Assets/Scripts/MonoBehaviours/UI/UpgradeScreen.cs"
      provides: "Placeholder upgrade screen with start run button"
      contains: "Start Run"
    - path: "Assets/Scripts/States/PlayingState.cs"
      provides: "Timer countdown and transition to Collecting"
      contains: "TransitionTo"
    - path: "Assets/Scripts/States/CollectingState.cs"
      provides: "Wait for minerals collected, transition to GameOver"
      contains: "MineralTag"
  key_links:
    - from: "Assets/Scripts/States/PlayingState.cs"
      to: "Assets/Scripts/ECS/Components/GameStateComponents.cs"
      via: "Decrements GameStateData.Timer each frame, triggers Collecting transition at 0"
      pattern: "Timer.*DeltaTime"
    - from: "Assets/Scripts/MonoBehaviours/UI/HUDController.cs"
      to: "Assets/Scripts/Shared/NumberFormatter.cs"
      via: "Formats GameStateData.Credits for display"
      pattern: "NumberFormatter\\.Format"
    - from: "Assets/Scripts/States/UpgradingState.cs"
      to: "Assets/Scripts/MonoBehaviours/Core/GameManager.cs"
      via: "Start Run button triggers TransitionTo(Playing) with entity cleanup"
      pattern: "TransitionTo.*Playing"
---

<objective>
Session flow: timed runs with HUD (credits + timer), phase transitions (Playing -> Collecting -> GameOver -> Upgrading -> Playing), results screen, upgrade placeholder, and run reset.

Purpose: This closes the game loop. Players now have a timed challenge, see their earnings, review results, and can start fresh runs. Without this, minerals collect silently with no session structure.

Output: HUDController, ResultsScreen, UpgradeScreen, updated state classes (Playing, Collecting, GameOver, Upgrading), extended UISetup and ECSBootstrap.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-collection-economy-and-session/03-RESEARCH.md
@.planning/phases/03-collection-economy-and-session/03-01-SUMMARY.md

@Assets/Scripts/States/PlayingState.cs
@Assets/Scripts/States/CollectingState.cs
@Assets/Scripts/States/GameOverState.cs
@Assets/Scripts/States/UpgradingState.cs
@Assets/Scripts/MonoBehaviours/Core/UISetup.cs
@Assets/Scripts/MonoBehaviours/Core/GameManager.cs
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
@Assets/Scripts/ECS/Components/GameStateComponents.cs
@Assets/Scripts/ECS/Components/MineralComponents.cs
@Assets/Scripts/Shared/NumberFormatter.cs
@Assets/Scripts/Shared/GameConstants.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: State machine updates (PlayingState timer, CollectingState mineral check, GameOverState/UpgradingState transitions) and GameManager run reset</name>
  <files>
    Assets/Scripts/States/PlayingState.cs
    Assets/Scripts/States/CollectingState.cs
    Assets/Scripts/States/GameOverState.cs
    Assets/Scripts/States/UpgradingState.cs
    Assets/Scripts/MonoBehaviours/Core/GameManager.cs
    Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
  </files>
  <action>
    **PlayingState.cs** -- Full rewrite of the stub:
    - `Enter()`: Initialize GameStateData.Timer to `GameConstants.DefaultRunDuration` and reset `Credits` for this run's session tracking. Access world via `World.DefaultGameObjectInjectionWorld`, get EntityManager, query GameStateData singleton, set `Timer = GameConstants.DefaultRunDuration`. Log entry.
    - `Execute()`: Each frame, read GameStateData singleton, decrement `Timer -= Time.deltaTime`. Write back. When `Timer <= 0f`, set `Timer = 0f`, write back, call `manager.TransitionTo(GamePhase.Collecting)`.
    - `Exit()`: Log exit.
    - Store `EntityManager _em` and `Entity _gameStateEntity` as private fields, resolved in Enter().
    - Use `em.GetComponentData<GameStateData>(entity)` / `em.SetComponentData(entity, data)` pattern (same as GameManager.WritePhaseToECS).
    - IMPORTANT: Do NOT reset GameStateData.Credits in Enter() -- credits are persistent across runs (ECON-03). Instead, track "credits this run" in the HUD by snapshotting credits at run start.

    **CollectingState.cs** -- Full rewrite of the stub:
    - `Enter()`: Log entry. Cache EntityManager, create EntityQuery for MineralTag and EntityQuery for AsteroidTag. Initialize `_gracePeriodTimer = 0f` and `_allCollected = false`.
    - `Execute()`: Count mineral entities and asteroid entities. When both counts are 0, start a grace period timer (`_gracePeriodTimer += Time.deltaTime`). When grace period >= `GameConstants.CollectingGracePeriod` (2 seconds), call `manager.TransitionTo(GamePhase.GameOver)`. If entities reappear during grace (edge case), reset the timer.
    - `Exit()`: Log exit.
    - The grace period handles the edge case where the last mineral is collected but ECB playback hasn't destroyed the entity yet.

    **GameOverState.cs** -- Full rewrite of the stub:
    - `Enter()`: Log entry. Find `ResultsScreen` via `Object.FindAnyObjectByType<ResultsScreen>()` and call `resultsScreen.Show(creditsThisRun)`. To get credits-this-run, read it from the ResultsScreen's tracked value or from HUDController. Alternative simpler approach: GameOverState reads GameStateData.Credits directly and the HUDController tracks the delta.
    - Actually, simplify: GameOverState.Enter() finds ResultsScreen and calls Show(). ResultsScreen itself reads GameStateData.Credits to display. Credits persistence is total across all runs.
    - `Execute()`: No-op (waiting for UI button).
    - `Exit()`: Find ResultsScreen and call Hide(). Log exit.

    **UpgradingState.cs** -- Full rewrite of the stub:
    - `Enter()`: Log entry. Find `UpgradeScreen` via `Object.FindAnyObjectByType<UpgradeScreen>()` and call `upgradeScreen.Show()`.
    - `Execute()`: No-op (waiting for UI button).
    - `Exit()`: Find UpgradeScreen and call Hide(). Log exit.

    **GameManager.cs** -- Add a public `ResetRun()` method:
    - Called before transitioning to Playing from Upgrading (the UpgradeScreen's Start Run button calls this).
    - Queries all entities with `AsteroidTag` and `MineralTag`, destroys them via EntityManager.DestroyEntity (synchronous, on main thread, safe in MonoBehaviour context).
    - Resets GameStateData fields: `Timer = GameConstants.DefaultRunDuration`, leave Credits as-is (persistent).
    - Add a `CreditsAtRunStart` field tracking: when PlayingState.Enter() runs, snapshot current Credits. Expose as `public long CreditsAtRunStart { get; set; }` so HUDController and ResultsScreen can compute "credits this run" = current credits - credits at run start.

    **ECSBootstrap.cs** -- Set initial GameStateData.Timer:
    - Change `Timer = 0f` to `Timer = GameConstants.DefaultRunDuration` so the first run starts with a countdown immediately.
  </action>
  <verify>
    Grep confirms:
    - `PlayingState.cs` contains `Timer -= Time.deltaTime` and `TransitionTo(GamePhase.Collecting)`
    - `CollectingState.cs` contains `MineralTag` count check and `TransitionTo(GamePhase.GameOver)`
    - `GameOverState.cs` contains `ResultsScreen` reference and `Show`
    - `UpgradingState.cs` contains `UpgradeScreen` reference and `Show`
    - `GameManager.cs` contains `ResetRun` method and `CreditsAtRunStart`
    - `ECSBootstrap.cs` Timer initialized to `DefaultRunDuration`
  </verify>
  <done>
    All 4 game states have real logic: Playing counts down and transitions to Collecting, Collecting waits for all entities cleared then transitions to GameOver, GameOver shows results, Upgrading shows upgrade screen. Run reset destroys leftover entities for clean new runs.
  </done>
</task>

<task type="auto">
  <name>Task 2: HUD, ResultsScreen, UpgradeScreen UI creation and UISetup integration</name>
  <files>
    Assets/Scripts/MonoBehaviours/UI/HUDController.cs
    Assets/Scripts/MonoBehaviours/UI/ResultsScreen.cs
    Assets/Scripts/MonoBehaviours/UI/UpgradeScreen.cs
    Assets/Scripts/MonoBehaviours/Core/UISetup.cs
  </files>
  <action>
    **HUDController.cs** -- MonoBehaviour for gameplay HUD:
    - Private fields: `TextMeshProUGUI _creditsText`, `TextMeshProUGUI _timerText`, `EntityManager _em`, `EntityQuery _gameStateQuery`, `bool _initialized`, `GameObject _hudRoot`.
    - `Initialize(TextMeshProUGUI creditsText, TextMeshProUGUI timerText, GameObject hudRoot)`: called by UISetup to wire references. Sets `_hudRoot = hudRoot`.
    - `Start()` or lazy init in LateUpdate: get ECS world + EntityManager, create GameStateData query.
    - `LateUpdate()`: if not initialized or world gone, return. Read GameStateData singleton.
      - Credits display: `_creditsText.text = NumberFormatter.Format((double)gameState.Credits)` -- shows running total.
      - Timer display: format as `MM:SS` -- `int minutes = (int)(gameState.Timer / 60f); int seconds = (int)(gameState.Timer % 60f); _timerText.text = $"{minutes}:{seconds:D2}"`.
      - Show HUD only during Playing and Collecting phases. Hide during GameOver and Upgrading: `_hudRoot.SetActive(gameState.Phase == GamePhase.Playing || gameState.Phase == GamePhase.Collecting)`.

    **ResultsScreen.cs** -- MonoBehaviour for run results:
    - Private fields: `TextMeshProUGUI _creditsEarnedText`, `TextMeshProUGUI _titleText`, `UnityEngine.UI.Button _continueButton`, `GameObject _root`.
    - `Initialize(TextMeshProUGUI titleText, TextMeshProUGUI creditsEarnedText, Button continueButton, GameObject root)`: wired by UISetup.
    - `Show()`: set `_root.SetActive(true)`. Read GameStateData.Credits and GameManager.CreditsAtRunStart. Display `creditsThisRun = credits - creditsAtRunStart`. Format with NumberFormatter. Set title to "Run Complete!".
    - `Hide()`: set `_root.SetActive(false)`.
    - Continue button onClick: `GameManager.Instance.TransitionTo(GamePhase.Upgrading)`.
    - Start hidden.

    **UpgradeScreen.cs** -- MonoBehaviour placeholder for Phase 6 tech tree:
    - Private fields: `TextMeshProUGUI _titleText`, `TextMeshProUGUI _creditsText`, `UnityEngine.UI.Button _startRunButton`, `GameObject _root`.
    - `Initialize(TextMeshProUGUI titleText, TextMeshProUGUI creditsText, Button startRunButton, GameObject root)`: wired by UISetup.
    - `Show()`: set `_root.SetActive(true)`. Read GameStateData.Credits, display formatted total. Set title to "Upgrades" (placeholder -- Phase 6 will populate with tech tree nodes).
    - `Hide()`: set `_root.SetActive(false)`.
    - Start Run button onClick: call `GameManager.Instance.ResetRun()` then `GameManager.Instance.TransitionTo(GamePhase.Playing)`.
    - Start hidden.

    **UISetup.cs** -- Extend Awake() to create HUD, Results, and Upgrade canvases:
    - Add `public HUDController HUDController { get; private set; }`, `public ResultsScreen ResultsScreen { get; private set; }`, `public UpgradeScreen UpgradeScreen { get; private set; }`.
    - `CreateHUDCanvas()`: New canvas (ScreenSpaceOverlay, sortingOrder 10). Use CanvasScaler with ScaleWithScreenSize (1920x1080 reference).
      - Credits text: anchor top-right, fontSize 24, white, text "0". Format: "$" prefix is not needed -- just the number.
      - Timer text: anchor top-center, fontSize 32, white, text "1:00".
      - Credits label: small "CREDITS" label above credits text, fontSize 12, light gray.
      - Timer has no label (the countdown is self-explanatory).
      - Create HUDController component on the canvas GO, call Initialize with the TMPro text references and the canvas GO as root.
    - `CreateResultsCanvas()`: New canvas (ScreenSpaceOverlay, sortingOrder 50).
      - Semi-transparent dark background panel (full screen, Color(0,0,0,0.85f)).
      - Title TMPro text: "Run Complete!", centered, fontSize 48, white.
      - Credits earned TMPro text: centered below title, fontSize 36, gold color (0.9f, 0.75f, 0.3f).
      - Continue button: centered below credits, 200x50 rect, dark gray background, white "Continue" text.
      - Add Button.onClick listener after creation.
      - Create ResultsScreen component, call Initialize, start hidden.
    - `CreateUpgradeCanvas()`: New canvas (ScreenSpaceOverlay, sortingOrder 50).
      - Solid dark background panel (full screen, Color(0.1f, 0.1f, 0.15f, 1f)).
      - Title TMPro text: "Upgrades", centered top, fontSize 40, white.
      - Credits TMPro text: top-right, fontSize 24, shows total credits.
      - Placeholder text: "Tech tree coming in Phase 6", centered, fontSize 20, gray.
      - Start Run button: centered bottom, 200x50, green-ish background (0.2f, 0.6f, 0.3f), white "Start Run" text.
      - Add Button.onClick listener after creation.
      - Create UpgradeScreen component, call Initialize, start hidden.
    - Call all three new create methods in Awake() after existing CreateFadeCanvas() and CreateDebugCanvas().
    - Reuse the existing `CreateTMPText` helper. Add a new helper `CreateButton(string name, string label, Transform parent, Vector2 size)` that creates a Button with Image background and TMPro text child.
  </action>
  <verify>
    All 4 files exist. Grep confirms:
    - `HUDController.cs` contains `NumberFormatter.Format` and `GameStateData`
    - `ResultsScreen.cs` contains `CreditsAtRunStart` and `TransitionTo(GamePhase.Upgrading)`
    - `UpgradeScreen.cs` contains `ResetRun` and `TransitionTo(GamePhase.Playing)`
    - `UISetup.cs` contains `CreateHUDCanvas`, `CreateResultsCanvas`, `CreateUpgradeCanvas`
  </verify>
  <done>
    During gameplay, HUD shows running credit total (formatted K/M/B/T) and countdown timer. On GameOver, results screen displays credits earned with a Continue button. Upgrade screen has a placeholder layout with Start Run button that resets and begins a new run. All UI is created programmatically by UISetup.
  </done>
</task>

</tasks>

<verification>
- PlayingState decrements timer and transitions to Collecting at 0
- CollectingState waits for mineral + asteroid count == 0 with grace period, then transitions to GameOver
- GameOverState shows ResultsScreen with credits earned this run
- UpgradingState shows UpgradeScreen with Start Run button
- HUD shows formatted credits and MM:SS timer during Playing and Collecting
- Start Run destroys leftover entities and transitions to Playing
- All UI created programmatically by UISetup (no manual scene setup for UI)
- Credits persist between runs within the same session (ECON-03 in-session) -- only timer resets. Cross-session persistence is 03-03's responsibility (SaveManager).
</verification>

<success_criteria>
A complete timed session plays out: 60-second countdown with HUD, timer expires to Collecting phase (minerals still fly), all collected triggers GameOver with results showing credits earned, Continue leads to Upgrade screen, Start Run begins a fresh 60-second run with clean entity state.
</success_criteria>

<output>
After completion, create `.planning/phases/03-collection-economy-and-session/03-02-SUMMARY.md`
</output>
