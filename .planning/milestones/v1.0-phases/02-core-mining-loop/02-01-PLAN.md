---
phase: 02-core-mining-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Assets/Scripts/ECS/Components/AsteroidComponents.cs
  - Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs
  - Assets/Scripts/ECS/Systems/AsteroidMovementSystem.cs
  - Assets/Scripts/ECS/Systems/AsteroidBoundsSystem.cs
  - Assets/Scripts/ECS/Systems/AsteroidDestructionSystem.cs
  - Assets/Scripts/MonoBehaviours/Core/AsteroidRenderer.cs
  - Assets/Scripts/Shared/GameConstants.cs
  - Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
  - Assets/Scripts/ECS/Components/PlaceholderComponents.cs
  - Assets/Scripts/ECS/Systems/PlaceholderMovementSystem.cs
autonomous: false
requirements:
  - ASTR-01
  - ASTR-02
  - ASTR-03
  - ASTR-04
  - ASTR-05
  - VISL-05

must_haves:
  truths:
    - "Asteroids spawn at the top of the screen and drift downward continuously"
    - "Asteroids visually rotate (spin) while drifting"
    - "Asteroids that reach the bottom of the screen disappear (destroyed)"
    - "Each asteroid has HP that can be read by other systems"
    - "Asteroids render as 3D spheres with color tinting"
    - "A ship placeholder is visible at the bottom of the screen"
  artifacts:
    - path: "Assets/Scripts/ECS/Components/AsteroidComponents.cs"
      provides: "AsteroidTag, HealthData, DamageTickTimer, AsteroidSpawnTimer, MiningConfigData components"
      contains: "AsteroidTag"
    - path: "Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs"
      provides: "Periodic asteroid entity creation via ECB"
      contains: "AsteroidSpawnSystem"
    - path: "Assets/Scripts/ECS/Systems/AsteroidMovementSystem.cs"
      provides: "Drift and spin for asteroid entities"
      contains: "AsteroidMovementSystem"
    - path: "Assets/Scripts/ECS/Systems/AsteroidBoundsSystem.cs"
      provides: "Destroys asteroids below play area via ECB"
      contains: "AsteroidBoundsSystem"
    - path: "Assets/Scripts/ECS/Systems/AsteroidDestructionSystem.cs"
      provides: "Destroys asteroids with 0 HP via ECB"
      contains: "AsteroidDestructionSystem"
    - path: "Assets/Scripts/MonoBehaviours/Core/AsteroidRenderer.cs"
      provides: "ECS-to-GameObject sync for dynamic asteroid lifecycle"
      contains: "AsteroidRenderer"
    - path: "Assets/Scripts/Shared/GameConstants.cs"
      provides: "Play area bounds, spawn defaults, mining defaults"
      contains: "GameConstants"
  key_links:
    - from: "AsteroidSpawnSystem"
      to: "AsteroidTag + HealthData + DriftData + SpinData + DamageTickTimer"
      via: "ECB.CreateEntity with full component archetype"
      pattern: "ecb\\.AddComponent.*AsteroidTag"
    - from: "AsteroidRenderer"
      to: "AsteroidTag entities"
      via: "EntityQuery in LateUpdate, Dictionary<Entity, GameObject> lifecycle"
      pattern: "_asteroidQuery"
    - from: "AsteroidBoundsSystem"
      to: "ECB.DestroyEntity"
      via: "Position Z check against lower bound"
      pattern: "DestroyEntity"
---

<objective>
Replace Phase 1 placeholder entities with a real asteroid lifecycle: asteroids spawn at the top of the screen via an ECS spawn system, drift downward with rotation, are destroyed when they leave the play area or reach 0 HP, and are rendered as colored 3D spheres via a pooled GameObject renderer. This also transitions the coordinate system from XY to XZ to align entities with the InputBridge's mouse projection plane.

Purpose: Establishes the asteroid simulation that the mining circle (Plan 02-02) will interact with. Without drifting, destructible asteroids, there is nothing to mine.

Output: 5 new ECS systems, new component definitions, AsteroidRenderer MonoBehaviour, GameConstants shared file, updated ECSBootstrap with new singletons.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-mining-loop/02-RESEARCH.md

# Existing code to understand patterns and replace:
@Assets/Scripts/ECS/Components/PlaceholderComponents.cs
@Assets/Scripts/ECS/Systems/PlaceholderMovementSystem.cs
@Assets/Scripts/MonoBehaviours/Core/PlaceholderSpawner.cs
@Assets/Scripts/MonoBehaviours/Core/PlaceholderRenderer.cs
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
@Assets/Scripts/MonoBehaviours/Pool/GameObjectPool.cs
@Assets/Scripts/MonoBehaviours/Bridge/InputBridge.cs
@Assets/Scripts/Shared/GameEnums.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ECS components, constants, singletons, and asteroid ECS systems</name>
  <files>
    Assets/Scripts/ECS/Components/AsteroidComponents.cs
    Assets/Scripts/Shared/GameConstants.cs
    Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
    Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs
    Assets/Scripts/ECS/Systems/AsteroidMovementSystem.cs
    Assets/Scripts/ECS/Systems/AsteroidBoundsSystem.cs
    Assets/Scripts/ECS/Systems/AsteroidDestructionSystem.cs
    Assets/Scripts/ECS/Components/PlaceholderComponents.cs
  </files>
  <action>
    **COORDINATE SYSTEM TRANSITION:** All entities in Phase 2 use the XZ plane (Y=0 ground plane, entities drift along -Z from top to bottom). This aligns with InputBridge which writes mouse as float2(worldPoint.x, worldPoint.z). The camera at Y=18 looking down at 60 degrees sees the XZ plane naturally.

    **1. Create `Assets/Scripts/Shared/GameConstants.cs`:**
    Static class with play area constants. These define the XZ-plane gameplay area visible from the camera:
    - `PlayAreaXMin = -12f`, `PlayAreaXMax = 12f` (horizontal bounds, matching PlaceholderSpawner)
    - `PlayAreaZMin = -8f` (bottom of visible area -- where asteroids are destroyed)
    - `PlayAreaZMax = 12f` (top of visible area -- where asteroids spawn)
    - `ShipPositionZ = -6f` (ship sits near bottom)
    - Default asteroid settings: `DefaultSpawnInterval = 1.5f`, `DefaultMaxAsteroids = 50`, `DefaultAsteroidHP = 100f`, `DefaultDriftSpeedMin = 1.0f`, `DefaultDriftSpeedMax = 3.0f`, `DefaultSpinMin = 0.5f`, `DefaultSpinMax = 3.0f`
    - Default mining settings (consumed by Plan 02-02 but defined here for singleton init): `DefaultMiningRadius = 2.5f`, `DefaultDamagePerTick = 10f`, `DefaultTickInterval = 0.25f`

    **2. Create `Assets/Scripts/ECS/Components/AsteroidComponents.cs`:**
    All unmanaged IComponentData structs, Burst-compatible:
    - `AsteroidTag : IComponentData {}` -- Tag to identify asteroid entities
    - `HealthData : IComponentData { float MaxHP; float CurrentHP; }` -- Reusable for any damageable entity
    - `DamageTickTimer : IComponentData { float Elapsed; }` -- Per-asteroid damage tick accumulator (used by Plan 02-02 MiningDamageSystem)
    - `AsteroidSpawnTimer : IComponentData { float SpawnInterval; float TimeUntilNextSpawn; int MaxActiveAsteroids; }` -- Singleton for spawn control
    - `MiningConfigData : IComponentData { float Radius; float DamagePerTick; float TickInterval; }` -- Singleton for mining stats (used by Plan 02-02, initialized here)

    **3. Update `Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs`:**
    Add creation of three new singletons after existing GameStateData and InputData creation:
    - `AsteroidSpawnTimer` singleton with values from GameConstants (SpawnInterval, TimeUntilNextSpawn=0, MaxActiveAsteroids)
    - `MiningConfigData` singleton with values from GameConstants (Radius, DamagePerTick, TickInterval)
    Keep existing GameStateData and InputData creation unchanged.

    **4. Create `Assets/Scripts/ECS/Systems/AsteroidSpawnSystem.cs`:**
    `[BurstCompile] public partial struct AsteroidSpawnSystem : ISystem`
    - OnUpdate: Check `GameStateData.Phase == GamePhase.Playing`, return if not
    - Read `AsteroidSpawnTimer` singleton (GetSingletonRW), decrement TimeUntilNextSpawn by DeltaTime
    - If timer <= 0: reset timer, count existing asteroids with `AsteroidTag` using a query (`.CalculateEntityCount()`), skip if >= MaxActiveAsteroids
    - Get ECB from `EndSimulationEntityCommandBufferSystem.Singleton.CreateCommandBuffer(state.WorldUnmanaged)`
    - Create entity via ECB with components: `AsteroidTag`, `LocalTransform` (random X between PlayAreaXMin/XMax, Y=0, Z=PlayAreaZMax), `LocalToWorld`, `DriftData` (random speed), `SpinData` (random speed), `HealthData` (MaxHP=CurrentHP=DefaultAsteroidHP), `DamageTickTimer` (Elapsed=0)
    - Use `Unity.Mathematics.Random` seeded from a uint field initialized in OnCreate (seed from `(uint)System.Environment.TickCount` or similar -- store as field `_rng` of type `Random`, initialize in OnCreate with a non-zero seed)
    - IMPORTANT: For the entity query to count asteroids, create a private `EntityQuery _asteroidQuery` in OnCreate using `state.GetEntityQuery(ComponentType.ReadOnly<AsteroidTag>())`

    **5. Create `Assets/Scripts/ECS/Systems/AsteroidMovementSystem.cs`:**
    `[BurstCompile] public partial struct AsteroidMovementSystem : ISystem`
    - OnUpdate: Check `GameStateData.Phase == GamePhase.Playing`, return if not
    - Schedule two IJobEntity jobs (same pattern as PlaceholderMovementSystem):
      - `AsteroidDriftJob`: `Execute(ref LocalTransform transform, in DriftData drift)` -- `transform.Position.z -= drift.Speed * DeltaTime` (drift along -Z, NOT -Y)
      - `AsteroidSpinJob`: `Execute(ref LocalTransform transform, in SpinData spin)` -- `transform = transform.RotateY(spin.RadiansPerSecond * DeltaTime)` (same as PlaceholderSpinJob)
    - Both jobs should have `[BurstCompile]` and `WithAll<AsteroidTag>` filter so they only affect asteroids, not future entity types

    **6. Create `Assets/Scripts/ECS/Systems/AsteroidBoundsSystem.cs`:**
    `[BurstCompile] public partial struct AsteroidBoundsSystem : ISystem`
    - OnUpdate: Check `GameStateData.Phase == GamePhase.Playing`, return if not
    - Get ECB from `EndSimulationEntityCommandBufferSystem.Singleton`
    - Iterate all entities with `AsteroidTag` + `LocalTransform` using `SystemAPI.Query` with `WithEntityAccess()`
    - If `transform.Position.z < GameConstants.PlayAreaZMin`: `ecb.DestroyEntity(entity)`
    - NOTE: GameConstants is a static class, so its fields are accessible from Burst IF they are const/static readonly primitive types. Use `const float` for bounds.

    **7. Create `Assets/Scripts/ECS/Systems/AsteroidDestructionSystem.cs`:**
    `[BurstCompile] public partial struct AsteroidDestructionSystem : ISystem`
    - OnUpdate: Get ECB from `EndSimulationEntityCommandBufferSystem.Singleton`
    - Iterate entities with `AsteroidTag` + `HealthData` using `SystemAPI.Query<RefRO<HealthData>>().WithAll<AsteroidTag>().WithEntityAccess()`
    - If `health.CurrentHP <= 0f`: `ecb.DestroyEntity(entity)`
    - No game state check needed (destroying 0-HP entities should happen regardless of phase)

    **8. Update `Assets/Scripts/ECS/Components/PlaceholderComponents.cs`:**
    Keep `DriftData` and `SpinData` (reused by asteroid systems). Keep `PlaceholderTag` for now (PlaceholderRenderer still references it, but it will be disabled/replaced by AsteroidRenderer in Task 2). Consider renaming the file to `MovementComponents.cs` or leaving as-is -- leave as-is to minimize churn; the file can be renamed in a future cleanup.
  </action>
  <verify>
    Open project in Unity Editor. Verify no compilation errors. Verify AsteroidSpawnTimer and MiningConfigData singletons are created (check ECSBootstrap console log or add a log line). Verify AsteroidSpawnSystem, AsteroidMovementSystem, AsteroidBoundsSystem, AsteroidDestructionSystem appear in the Systems window (Window > Entities > Systems). If entering Play mode, asteroids should spawn as ECS entities (visible in Entity Debugger) but won't have visual representation until Task 2.
  </verify>
  <done>
    All 5 ECS systems compile and are registered. AsteroidSpawnSystem creates entities with AsteroidTag, HealthData, DriftData, SpinData, DamageTickTimer, LocalTransform (on XZ plane at Y=0). AsteroidMovementSystem drifts them along -Z and spins them. AsteroidBoundsSystem destroys entities below PlayAreaZMin. AsteroidDestructionSystem destroys entities with CurrentHP <= 0. GameConstants defines all tunable values. ECSBootstrap creates AsteroidSpawnTimer and MiningConfigData singletons.
  </done>
</task>

<task type="auto">
  <name>Task 2: AsteroidRenderer, ship visual, and placeholder cleanup</name>
  <files>
    Assets/Scripts/MonoBehaviours/Core/AsteroidRenderer.cs
    Assets/Scripts/MonoBehaviours/Core/PlaceholderSpawner.cs
    Assets/Scripts/MonoBehaviours/Core/PlaceholderRenderer.cs
    Assets/Scripts/ECS/Systems/PlaceholderMovementSystem.cs
  </files>
  <action>
    **1. Create `Assets/Scripts/MonoBehaviours/Core/AsteroidRenderer.cs`:**
    MonoBehaviour that syncs ECS asteroid entities to pooled GameObjects. Follows the PlaceholderRenderer pattern but handles dynamic entity lifecycle (entities created/destroyed at runtime, not all at once).

    Key design:
    - `Dictionary<Entity, GameObject> _entityToGO` tracks active mappings
    - `List<Entity> _entitiesToRemove` temp list for cleanup (avoids alloc per frame)
    - `EntityQuery _asteroidQuery` queries `AsteroidTag` + `LocalTransform`
    - `GameObjectPool _asteroidPool` wraps pooled sphere GameObjects
    - Pre-warm pool with `GameConstants.DefaultMaxAsteroids + 20` objects (headroom for spawn/destroy overlap)

    Setup (in Start or coroutine after one frame for ECS readiness):
    - Wait one frame (coroutine yield null) for ECSBootstrap to run
    - Get EntityManager from World.DefaultGameObjectInjectionWorld
    - Create EntityQuery for (AsteroidTag, LocalTransform)
    - Create asteroid prefab: `GameObject.CreatePrimitive(PrimitiveType.Sphere)`, remove Collider, SetActive(false), parent to self
    - Create GameObjectPool with prefab, pre-warm count = `GameConstants.DefaultMaxAsteroids + 20`, max = `GameConstants.DefaultMaxAsteroids + 50`
    - Create ship placeholder (same as PlaceholderRenderer.CreateShipPlaceholder but positioned on XZ plane): position at `(0, 0, GameConstants.ShipPositionZ)`, scale `(1.0f, 0.1f, 0.5f)`, rotated 45 degrees on Y, light gray color via MaterialPropertyBlock. The ship sits at Y=0 on the XZ plane.

    LateUpdate sync loop (runs every frame after ECS systems complete):
    - If not initialized, return
    - Get all entities from _asteroidQuery as `NativeArray<Entity>` with `Allocator.Temp`
    - Build `HashSet<Entity>` of currently active entities
    - For each entity:
      - If NOT in _entityToGO: this is a new asteroid. Call `_asteroidPool.Get()`, configure visual (random scale 0.8-1.5, random color from AsteroidColors array via MaterialPropertyBlock on `_BaseColor`), add to _entityToGO. Use a `Unity.Mathematics.Random` field for deterministic randomness (seed once in init).
      - Get `LocalTransform` from EntityManager, sync position: `go.transform.position = new Vector3(lt.Position.x, lt.Position.y, lt.Position.z)`, sync rotation: `go.transform.rotation = lt.Rotation`
    - Cleanup pass: iterate _entityToGO, if entity NOT in activeEntities HashSet, release GameObject to pool, add to _entitiesToRemove. After iteration, remove all from _entityToGO.
    - Dispose entity NativeArray

    Color palette (asteroid colors, same as PlaceholderRenderer):
    ```
    dark gray: (0.333, 0.333, 0.333)
    brown: (0.545, 0.412, 0.078)
    rust: (0.718, 0.255, 0.055)
    ```

    **2. Disable placeholder systems:**
    - **PlaceholderSpawner.cs:** Add `[System.Obsolete("Replaced by AsteroidSpawnSystem in Phase 2")]` attribute to the class. In Start(), add an early return: `enabled = false; return;` so it does nothing. OR: simply disable the component in the scene. Since UISetup/GameManager don't reference it by code, the cleanest approach is to wrap the entire Start() body in `#if false` or just comment out the coroutine start and add a note. Prefer: set `enabled = false` at the top of Start() and log a message: `"PlaceholderSpawner disabled -- replaced by AsteroidSpawnSystem"`.
    - **PlaceholderRenderer.cs:** Same approach -- disable in Start() with log message. The AsteroidRenderer replaces it entirely.
    - **PlaceholderMovementSystem.cs:** Add `[DisableAutoCreation]` attribute to the struct so Unity doesn't register it. This prevents it from running without deleting the file (which could cause issues if anything references DriftData/SpinData from it -- though the jobs themselves only run on PlaceholderTag entities, they also process DriftData/SpinData generically). Actually, PlaceholderDriftJob and PlaceholderSpinJob run on ALL entities with DriftData/SpinData (no tag filter). This means they would ALSO process asteroid entities. To prevent double-processing: add `[DisableAutoCreation]` to `PlaceholderMovementSystem` so it never runs, and let `AsteroidMovementSystem` handle all drift/spin for AsteroidTag entities. If minerals need drift later (Phase 3), a separate system can handle them.

    **3. Verify the scene has necessary MonoBehaviours:**
    The user will need to add AsteroidRenderer to a GameObject in the scene. Add a note in verify that they should:
    - Add an AsteroidRenderer component to the existing GameManager GameObject (or create a new empty "Rendering" GameObject)
    - Ensure PlaceholderSpawner and PlaceholderRenderer are either removed from the scene or their disabled-in-code logic handles it
  </action>
  <verify>
    Enter Play mode in Unity Editor. Verify:
    1. Asteroids (spheres) appear at the top of the screen and drift downward
    2. Asteroids visually rotate while drifting
    3. Asteroids disappear when they reach the bottom of the visible area
    4. New asteroids continue spawning (steady stream)
    5. The ship placeholder cube is visible near the bottom of the screen
    6. No errors in Console related to entity lifecycle or pool exhaustion
    7. Entity count in debug overlay or Entity Debugger shows asteroids being created and destroyed
    8. PlaceholderMovementSystem does NOT appear as running in Systems window (disabled)
  </verify>
  <done>
    Asteroids spawn at the top, drift downward on the XZ plane with visible rotation, and are destroyed when they exit the bottom boundary. The AsteroidRenderer dynamically assigns pooled GameObjects to new ECS entities and releases them when entities are destroyed. The ship placeholder is positioned on the XZ plane. Placeholder systems are disabled and do not interfere.
  </done>
</task>

</tasks>

<verification>
Phase 2 Plan 01 overall checks:
- Asteroids spawn continuously at the top of the screen (Z = PlayAreaZMax)
- Asteroids drift downward (along -Z) with visible spin rotation
- Asteroids are destroyed when they pass below PlayAreaZMin
- Asteroids have HealthData that can be read/modified by future systems (Plan 02-02)
- Each asteroid has a DamageTickTimer component ready for the mining damage system
- MiningConfigData singleton exists and is initialized with default values
- Ship placeholder visible at bottom of screen
- No placeholder systems running (disabled or removed)
- Entity coordinate system is XZ plane (Y=0), consistent with InputBridge mouse projection
- GameObjectPool handles dynamic asteroid lifecycle without leaks or ghost objects
</verification>

<success_criteria>
1. In Play mode, a steady stream of asteroids (3D spheres) spawns at the top of the screen and drifts downward with rotation
2. Asteroids disappear at the bottom boundary (no entities accumulating infinitely)
3. A ship visual is present near the bottom of the screen
4. Entity Debugger shows AsteroidTag entities with HealthData, DriftData, SpinData, DamageTickTimer components
5. Zero compilation errors, zero runtime errors in Console
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-mining-loop/02-01-SUMMARY.md`
</output>
