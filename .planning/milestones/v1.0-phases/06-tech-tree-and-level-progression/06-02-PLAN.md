---
phase: 06-tech-tree-and-level-progression
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - Assets/Scripts/MonoBehaviours/UI/TechTreeController.cs
  - Assets/Scripts/MonoBehaviours/UI/TechTreeNode.cs
  - Assets/Scripts/MonoBehaviours/UI/TechTreeTooltip.cs
  - Assets/Scripts/MonoBehaviours/UI/UpgradeScreen.cs
  - Assets/Scripts/MonoBehaviours/Core/UISetup.cs
  - Assets/ScriptableObjects/TechTree/TechTreeDefinition.asset
autonomous: true
requirements: [TECH-01, TECH-07, TECH-09]

must_haves:
  truths:
    - "Tech tree UI displays between runs with 5 branches radiating from a center START node"
    - "Player can pan (drag) and zoom (scroll) the tech tree freely"
    - "Nodes show 4 visual states: blue (purchased), green (affordable), red (connected but too expensive), hidden (unrevealed)"
    - "Clicking a green node instantly purchases it: deducts credits, applies stat effect to ECS singletons, plays cha-ching sound and particle burst"
    - "Hovering a visible node shows tooltip with name, cost, effect description, and current vs next stat values"
    - "Nodes reveal progressively as connected nodes are purchased"
    - "Prerequisite gating enforced: cannot buy a node unless all prerequisites are purchased"
    - "Credit total always visible at top of tech tree screen"
  artifacts:
    - path: "Assets/Scripts/MonoBehaviours/UI/TechTreeController.cs"
      provides: "Main tech tree controller: node graph rendering, pan/zoom, purchase logic, stat application to ECS singletons, save integration"
      contains: "class TechTreeController"
    - path: "Assets/Scripts/MonoBehaviours/UI/TechTreeNode.cs"
      provides: "Individual node UI element: Image + cost text + click handler + color state management"
      contains: "class TechTreeNode"
    - path: "Assets/Scripts/MonoBehaviours/UI/TechTreeTooltip.cs"
      provides: "Hover tooltip showing node details with current vs next stat preview"
      contains: "class TechTreeTooltip"
    - path: "Assets/Scripts/MonoBehaviours/Core/UISetup.cs"
      provides: "Rewritten CreateUpgradeCanvas that builds the tech tree container with mask, content panel, and credit display"
      contains: "CreateUpgradeCanvas"
  key_links:
    - from: "Assets/Scripts/MonoBehaviours/UI/TechTreeController.cs"
      to: "Assets/Scripts/ECS/Components/AsteroidComponents.cs"
      via: "ApplyStatEffect writes to MiningConfigData, CritConfigData singletons"
      pattern: "MiningConfigData|CritConfigData"
    - from: "Assets/Scripts/MonoBehaviours/UI/TechTreeController.cs"
      to: "Assets/Scripts/ECS/Components/SkillComponents.cs"
      via: "ApplyStatEffect writes to SkillStatsData, SkillUnlockData singletons"
      pattern: "SkillStatsData|SkillUnlockData"
    - from: "Assets/Scripts/MonoBehaviours/UI/TechTreeController.cs"
      to: "Assets/Scripts/MonoBehaviours/Save/SaveManager.cs"
      via: "Persists tech tree unlocks after each purchase"
      pattern: "SaveManager.*Save"
    - from: "Assets/Scripts/MonoBehaviours/Core/UISetup.cs"
      to: "Assets/Scripts/MonoBehaviours/UI/TechTreeController.cs"
      via: "UISetup creates canvas structure and initializes TechTreeController"
      pattern: "TechTreeController"
---

<objective>
Build the complete tech tree UI and purchase system: a center-outward node-and-line graph with pan/zoom navigation, 4-state color coding (blue/green/red/hidden), one-click purchasing that immediately applies stat effects to ECS singletons, hover tooltips, purchase VFX/SFX, and progressive node revelation. Also creates all ~40 ScriptableObject node asset instances programmatically.

Purpose: This is the primary player-facing feature of Phase 6 -- the screen where players spend their hard-earned credits on meaningful upgrades that make the next run noticeably better.

Output: TechTreeController, TechTreeNode, TechTreeTooltip MonoBehaviours; rewritten UpgradeScreen/UISetup integration; all node ScriptableObject assets; functional purchase-and-apply flow.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-tech-tree-and-level-progression/06-RESEARCH.md
@.planning/phases/06-tech-tree-and-level-progression/06-CONTEXT.md
@.planning/phases/06-tech-tree-and-level-progression/06-01-SUMMARY.md
@Assets/Scripts/Data/UpgradeNodeSO.cs
@Assets/Scripts/Data/TechTreeSO.cs
@Assets/Scripts/Data/LevelConfigSO.cs
@Assets/Scripts/Shared/GameEnums.cs
@Assets/Scripts/ECS/Components/EconomyComponents.cs
@Assets/Scripts/ECS/Components/SkillComponents.cs
@Assets/Scripts/ECS/Components/AsteroidComponents.cs
@Assets/Scripts/ECS/Components/GameStateComponents.cs
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
@Assets/Scripts/MonoBehaviours/Core/UISetup.cs
@Assets/Scripts/MonoBehaviours/UI/UpgradeScreen.cs
@Assets/Scripts/MonoBehaviours/UI/SkillBarController.cs
@Assets/Scripts/MonoBehaviours/Save/SaveData.cs
@Assets/Scripts/MonoBehaviours/Save/SaveManager.cs
@Assets/Scripts/Shared/GameConstants.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build TechTreeController with node rendering, pan/zoom, purchase logic, and stat application</name>
  <files>
    Assets/Scripts/MonoBehaviours/UI/TechTreeController.cs
    Assets/Scripts/MonoBehaviours/UI/TechTreeNode.cs
    Assets/Scripts/MonoBehaviours/UI/UpgradeScreen.cs
    Assets/Scripts/MonoBehaviours/Core/UISetup.cs
  </files>
  <action>
    **TechTreeNode.cs** -- New MonoBehaviour for individual node UI elements:
    - Fields: `UpgradeNodeSO nodeData`, `Image backgroundImage`, `TextMeshProUGUI costText`, `bool isPurchased`, `bool isRevealed`
    - Public `enum NodeState { Hidden, Locked, Available, TooExpensive, Purchased }` -- maps to visual states
    - `Initialize(UpgradeNodeSO data, RectTransform parent)` -- creates the node's visual hierarchy:
      - Root GameObject with RectTransform at data.GraphPosition * nodeSpacing (scaled for readability)
      - Background Image (60x60 px circle-like square with rounded color)
      - Cost TextMeshProUGUI below node showing data.ActualCost formatted with NumberFormatter
      - Name TextMeshProUGUI above node showing data.DisplayName (small font)
      - Button component for click handling (wired to TechTreeController.OnNodeClicked)
    - `UpdateState(NodeState state, long playerCredits)` -- sets visual appearance:
      - Hidden: gameObject.SetActive(false)
      - Purchased: blue (#3498DB), cost text hidden
      - Available: green (#2ECC71), cost text visible
      - TooExpensive: red (#E74C3C), cost text visible
      - Locked: should not render (same as hidden for now, reserved for future)
    - `PlayPurchaseEffect()` -- fast color lerp from green to blue, brief scale punch (1.0 -> 1.2 -> 1.0 over 0.3s via coroutine)

    **TechTreeController.cs** -- New MonoBehaviour (the main controller):

    **Fields:**
    - `TechTreeSO treeData` -- reference set by UISetup or UpgradeScreen
    - `RectTransform contentPanel` -- the pannable/zoomable content container
    - `RectTransform viewportPanel` -- the masked viewport area
    - `TextMeshProUGUI creditsText` -- always-visible credit display
    - `TechTreeNode[] nodeUIs` -- runtime node UI elements
    - `bool[] purchasedNodes` -- mirrors save state
    - `Dictionary<string, int> nodeIdToIndex` -- for quick lookup
    - Zoom: `float currentZoom = 1f`, `float minZoom = 0.3f`, `float maxZoom = 2f`, `float zoomSpeed = 0.1f`
    - Pan: `bool isDragging`, `Vector2 lastDragPos`
    - Lazy ECS init: `bool ecsInitialized`, queries for all singleton types

    **Initialize(TechTreeSO data, RectTransform content, RectTransform viewport, TextMeshProUGUI credits):**
    - Store references
    - Build nodeIdToIndex dictionary
    - Load purchased state from SaveManager.Instance.CurrentSave.TechTreeUnlocks
    - If TechTreeUnlocks is empty/wrong size, resize to AllNodes.Length (all false)
    - START node is always purchased (index 0 or whatever StartNode maps to)
    - Call BuildNodeGraph()
    - Call BuildConnectionLines()

    **BuildNodeGraph():**
    - For each node in treeData.AllNodes:
      - Create TechTreeNode, call Initialize() with nodeData and contentPanel
      - Position at node.GraphPosition * spacing constant (e.g., 150 units per graph unit)
      - Wire button click to OnNodeClicked(nodeIndex)
    - Call RefreshAllNodeStates()

    **BuildConnectionLines():**
    - For each node, for each prerequisite, draw a line between them:
      - Create a child GameObject with Image + RectTransform
      - Calculate position as midpoint of (fromPos + toPos)
      - Width = distance between nodes, height = 3px
      - Rotation = angle between the two positions
      - Color: gray (0.4, 0.4, 0.4, 0.6) for unrevealed, lighter for revealed
    - Lines are children of contentPanel so they pan/zoom with content

    **RefreshAllNodeStates():**
    - For each node, determine state:
      - If purchased: NodeState.Purchased
      - If IsRevealed(nodeIndex) AND CanAfford(nodeIndex): NodeState.Available
      - If IsRevealed(nodeIndex) AND !CanAfford(nodeIndex): NodeState.TooExpensive
      - Otherwise: NodeState.Hidden
    - IsRevealed(index): node has at least one prerequisite that is purchased (OR node has zero prerequisites and is connected to START)
    - CanAfford(index): current credits >= node.ActualCost AND all prerequisites purchased (TECH-07)
    - Update credit display: creditsText.text = NumberFormatter.Format(credits) + " credits"

    **OnNodeClicked(int nodeIndex):**
    - If node already purchased, return
    - If !CanAfford(nodeIndex), return (shouldn't happen since green = affordable, but defense)
    - Deduct credits: modify GameStateData.Credits via EntityManager
    - Mark purchased: purchasedNodes[nodeIndex] = true
    - Apply effects: for each StatEffect in nodeData.Effects, call ApplyStatEffect(effect)
    - Play purchase feedback: nodeUIs[nodeIndex].PlayPurchaseEffect()
    - Play "cha-ching" SFX via AudioManager.Instance?.PlayPurchaseSFX() (add this method or reuse PlayUIClick)
    - Save immediately: update SaveManager.Instance.CurrentSave.TechTreeUnlocks and call SaveManager.Instance.Save()
    - Call RefreshAllNodeStates() to update all node visuals (newly revealed nodes appear)

    **ApplyStatEffect(StatEffect effect):**
    - Use lazy ECS init pattern (same as SkillBarController.TryInitECS)
    - Switch on effect.Target:
      - MiningRadius: read MiningConfigData, add effect.Value to Radius, write back
      - MiningDamage: read MiningConfigData, add effect.Value to DamagePerTick, write back
      - MiningTickInterval: read MiningConfigData, subtract effect.Value from TickInterval (min 0.05), write back
      - CritChance: read CritConfigData, add effect.Value to CritChance, write back
      - CritMultiplier: read CritConfigData, add effect.Value to CritMultiplier, write back
      - ResourceMultiplier: read PlayerBonusData, multiply ResourceMultiplier by (1 + effect.Value), write back
      - LuckyStrikeChance: read PlayerBonusData, add effect.Value to LuckyStrikeChance, write back
      - SpawnRateReduction: read RunConfigData, subtract effect.Value from SpawnInterval (min 0.3), write back
      - MaxAsteroidsBonus: read RunConfigData, add (int)effect.Value to MaxActiveAsteroids, write back
      - SkillUnlock: read SkillUnlockData, set SkillN_Unlocked = true based on SkillIndex, write back. Also update SkillBarController visibility.
      - LaserDamage/LaserCooldown/ChainDamage/etc: read SkillStatsData, modify the matching field, write back
      - RunDuration: read RunConfigData, add effect.Value to RunDuration, write back
      - AdvanceLevel: read RunConfigData, increment CurrentLevel, write back. Load the corresponding LevelConfigSO and apply its settings (HP multiplier, spawn interval, max asteroids) to RunConfigData.
      - ComboMastery: read PlayerBonusData, set ComboMasteryMultiplier to effect.Value, write back
      - DotDamage/DotDuration: read SkillStatsData, modify laser/EMP DoT fields, write back
    - Also update SaveData.Stats with the new values (so they persist)

    **Pan/Zoom in Update() (New Input System -- UnityEngine.InputSystem):**
    - Read `Mouse.current` (MUST use new Input System per user mandate)
    - Zoom: `var scroll = Mouse.current.scroll.ReadValue().y;` If abs > 0.01:
      - Calculate new scale = Clamp(currentZoom + scroll * zoomSpeed, minZoom, maxZoom)
      - Get mouse local position via RectTransformUtility.ScreenPointToLocalPointInRectangle
      - Adjust contentPanel.anchoredPosition to zoom toward mouse pivot
      - Set contentPanel.localScale = Vector3.one * newZoom
    - Pan: Check Mouse.current.rightButton.isPressed (use right-click for pan to avoid conflict with node clicks):
      - On press start: isDragging = true, lastDragPos = Mouse.current.position.ReadValue()
      - While pressed: delta = current - lastDragPos, contentPanel.anchoredPosition += delta, update lastDragPos
      - On release: isDragging = false
    - Alternative: also support middle-mouse drag for pan

    **UpgradeScreen.cs** -- Heavily refactor:
    - Keep the existing Show/Hide/OnStartRunClicked structure
    - Add `TechTreeController techTreeController` field
    - In Show(): call techTreeController.RefreshAllNodeStates() to update with latest credits
    - Remove the placeholder text reference
    - Add Initialize overload or extend existing to accept TechTreeController reference

    **UISetup.cs** -- Rewrite `CreateUpgradeCanvas()`:
    - Keep the same Canvas setup (Sort Order 50, ScreenSpaceOverlay, ScaleWithScreenSize)
    - Background panel: same dark color (0.1, 0.1, 0.15)
    - Add title text "Tech Tree" (top center)
    - Add credits text (top right) -- always visible per locked decision
    - Create viewport panel: full-screen area minus top bar, with RectMask2D component for clipping
    - Create content panel: large RectTransform (e.g., 4000x4000) as child of viewport -- this is the pannable/zoomable surface
    - Create TechTreeController on the canvas GO
    - Load TechTreeSO from Resources (place TechTreeDefinition.asset in Resources folder) or reference via field
    - Call TechTreeController.Initialize(treeData, contentPanel, viewportPanel, creditsText)
    - Keep Start Run button (bottom center, green)
    - Wire UpgradeScreen with TechTreeController reference

    **IMPORTANT per locked decisions:**
    - Center-outward layout: START node at (0,0), 5 branches radiate outward
    - Node colors: Blue (#3498DB) purchased, Green (#2ECC71) available, Red (#E74C3C) too expensive, Hidden = not rendered
    - One click to buy, no confirmation dialog
    - Cost shown on each visible node
    - Credits always visible at top
    - Progressive revelation: nodes only appear when a connected prerequisite is purchased
    - "Cha-ching" sound on purchase + brief particle burst (use a simple scale-punch + maybe spawn a few small UI particles)
  </action>
  <verify>
    Project compiles without errors. Check:
    - TechTreeController.cs exists with Initialize, BuildNodeGraph, OnNodeClicked, ApplyStatEffect methods
    - TechTreeNode.cs exists with UpdateState for all 4 visual states
    - UISetup.CreateUpgradeCanvas builds the tech tree container with viewport mask and content panel
    - UpgradeScreen wired to TechTreeController
    - Pan/zoom uses Mouse.current from UnityEngine.InputSystem (NOT UnityEngine.Input)
  </verify>
  <done>
    Tech tree controller builds a node graph from TechTreeSO data, supports pan/zoom navigation, renders nodes with 4-state color coding, handles click-to-purchase with immediate stat application to ECS singletons, plays purchase VFX/SFX, saves state after each purchase, and reveals nodes progressively. UISetup creates the tech tree canvas structure with viewport masking for the scrollable graph.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TechTreeTooltip and all ScriptableObject node asset instances</name>
  <files>
    Assets/Scripts/MonoBehaviours/UI/TechTreeTooltip.cs
    Assets/Scripts/MonoBehaviours/Audio/AudioManager.cs
    Assets/Scripts/MonoBehaviours/UI/TechTreeController.cs
  </files>
  <action>
    **TechTreeTooltip.cs** -- New MonoBehaviour for hover tooltip:
    - Fields: `GameObject tooltipRoot`, `TextMeshProUGUI nameText`, `TextMeshProUGUI costText`, `TextMeshProUGUI descriptionText`, `TextMeshProUGUI statPreviewText`, `RectTransform tooltipRect`
    - `Initialize(RectTransform parent)` -- creates tooltip UI hierarchy:
      - Root panel with dark semi-transparent background (0, 0, 0, 0.9)
      - Fixed width ~250px, height auto-fitted via ContentSizeFitter
      - VerticalLayoutGroup with padding
      - Name text (bold, 16pt, white)
      - Cost text (14pt, gold color)
      - Separator line (Image, 1px height, gray)
      - Description text (12pt, light gray, word wrap enabled)
      - Stat preview text (12pt, green for improvement): "Current: X -> Next: Y"
      - Initially hidden
    - `Show(UpgradeNodeSO node, bool isPurchased, Vector2 screenPos)`:
      - Set name, cost (NumberFormatter.Format), description
      - For stat preview: read current value from ECS singleton, compute next value by adding effect.Value, format as "Stat: current -> next" in green
      - Position tooltip near screenPos but clamped to screen bounds (don't let it go off-screen)
      - If isPurchased, show "PURCHASED" instead of cost, hide stat preview
      - tooltipRoot.SetActive(true)
    - `Hide()` -- tooltipRoot.SetActive(false)

    **Wire tooltip into TechTreeController:**
    - Add `TechTreeTooltip tooltip` field
    - In Initialize: create tooltip on content panel (or viewport for correct scaling)
    - On TechTreeNode: add IPointerEnterHandler and IPointerExitHandler to trigger tooltip Show/Hide
    - Tooltip follows mouse position while visible (update in TechTreeController.Update or via TechTreeNode)

    **AudioManager.cs** -- Add purchase SFX method:
    - Add `public void PlayPurchaseSFX()` method -- loads "Audio/SFX/purchase" clip via Resources.Load (or reuse an existing chime with higher pitch)
    - If no dedicated purchase clip exists, use a pitched-up version of the collection chime as a placeholder (the executor can create a simple "cha-ching" by playing the collection chime at pitch 1.5)

    **ScriptableObject asset creation (programmatic):**
    Create a temporary editor script or use TechTreeController.BuildDefaultTree() to programmatically create all ~40 UpgradeNodeSO assets and the TechTreeDefinition.asset. The node definitions are:

    **Layout: START node at center (0,0). 5 branches extend outward:**

    Branch angles (approximate, Claude discretion on exact positions):
    - Mining: upper-left (135 degrees)
    - Economy: upper-right (45 degrees)
    - Ship: left (180 degrees)
    - Run: lower-left (225 degrees)
    - Progression: right (0 degrees)

    **Mining Branch (11 nodes, TECH-02):**
    Graph positions radiate outward along the Mining branch angle.
    All BaseCost values follow research economy balance (first upgrade ~500-800 credits).

    | Node | DisplayName | BaseCost | Tier | Prereqs | Effect |
    |------|-------------|----------|------|---------|--------|
    | mining_radius_1 | Circle Radius I | 500 | 1 | [START] | MiningRadius +0.5 |
    | mining_radius_2 | Circle Radius II | 800 | 2 | [radius_1] | MiningRadius +0.5 |
    | mining_radius_3 | Circle Radius III | 1200 | 3 | [radius_2] | MiningRadius +0.5 |
    | mining_damage_1 | Mining Damage I | 600 | 1 | [START] | MiningDamage +5 |
    | mining_damage_2 | Mining Damage II | 1000 | 2 | [damage_1] | MiningDamage +5 |
    | mining_rate_1 | Mining Rate I | 700 | 1 | [damage_1] | MiningTickInterval -0.05 |
    | mining_rate_2 | Mining Rate II | 1200 | 2 | [rate_1] | MiningTickInterval -0.05 |
    | mining_crit_chance | Crit Chance | 800 | 1 | [radius_1] | CritChance +0.05 |
    | mining_crit_multi | Crit Multiplier | 1000 | 2 | [crit_chance] | CritMultiplier +0.5 |
    | mining_dot_1 | Burning I | 900 | 1 | [damage_2] | DotDamage +2.0 |
    | mining_dot_2 | Burning II | 1500 | 2 | [dot_1] | DotDuration +1.0 |

    **Economy Branch (8 nodes, TECH-03):**
    | Node | DisplayName | BaseCost | Tier | Prereqs | Effect |
    |------|-------------|----------|------|---------|--------|
    | econ_mult_1 | Resource Multi I | 500 | 1 | [START] | ResourceMultiplier +0.15 |
    | econ_mult_2 | Resource Multi II | 900 | 2 | [mult_1] | ResourceMultiplier +0.15 |
    | econ_mult_3 | Resource Multi III | 1500 | 3 | [mult_2] | ResourceMultiplier +0.20 |
    | econ_lucky_1 | Lucky Strike I | 600 | 1 | [START] | LuckyStrikeChance +0.08 |
    | econ_lucky_2 | Lucky Strike II | 1000 | 2 | [lucky_1] | LuckyStrikeChance +0.08 |
    | econ_lucky_3 | Lucky Strike III | 1500 | 3 | [lucky_2] | LuckyStrikeChance +0.10 |
    | econ_abundance_1 | Abundance I | 700 | 1 | [mult_1] | SpawnRateReduction -0.2, MaxAsteroidsBonus +10 |
    | econ_abundance_2 | Abundance II | 1200 | 2 | [abundance_1] | SpawnRateReduction -0.2, MaxAsteroidsBonus +10 |

    **Ship Branch (13 nodes, TECH-04):**
    Each skill has unlock (tier 1) + 2 upgrade tiers. Plus Combo Mastery.
    | Node | DisplayName | BaseCost | Tier | Prereqs | Effect |
    |------|-------------|----------|------|---------|--------|
    | ship_laser_1 | Laser Burst | 600 | 1 | [START] | SkillUnlock (skill 1) |
    | ship_laser_2 | Laser Burst II | 1000 | 2 | [laser_1] | LaserDamage +50 |
    | ship_laser_3 | Laser Burst III | 1800 | 3 | [laser_2] | LaserDamage +75, LaserCooldown -1 |
    | ship_chain_1 | Chain Lightning | 600 | 1 | [START] | SkillUnlock (skill 2) |
    | ship_chain_2 | Chain Lightning II | 1000 | 2 | [chain_1] | ChainDamage +20, ChainTargets +1 |
    | ship_chain_3 | Chain Lightning III | 1800 | 3 | [chain_2] | ChainDamage +30, ChainCooldown -2 |
    | ship_emp_1 | EMP Pulse | 700 | 1 | [laser_1 OR chain_1] | SkillUnlock (skill 3) |
    | ship_emp_2 | EMP Pulse II | 1200 | 2 | [emp_1] | EmpDamage +30, EmpRadius +1 |
    | ship_emp_3 | EMP Pulse III | 2000 | 3 | [emp_2] | EmpDamage +40, EmpCooldown -2 |
    | ship_overcharge_1 | Overcharge | 800 | 1 | [emp_1] | SkillUnlock (skill 4) |
    | ship_overcharge_2 | Overcharge II | 1500 | 2 | [overcharge_1] | OverchargeDuration +2 |
    | ship_overcharge_3 | Overcharge III | 2500 | 3 | [overcharge_2] | OverchargeDamageMultiplier +0.5, OverchargeCooldown -2 |
    | ship_combo | Combo Mastery | 2000 | 2 | [emp_1, overcharge_1] | ComboMastery 1.5 |

    Note: EMP prereq is "laser_1 OR chain_1" -- implement as either prerequisite being purchased (the CanPurchase check: at least one of Prerequisites[] must be purchased for this specific case). For simplicity, make EMP's prerequisite list contain BOTH laser_1 AND chain_1, but the check for nodes with Branch==Ship and specific IDs uses OR logic. Alternatively, just pick one prereq (simpler): ship_emp_1 prereq = [ship_laser_1]. Claude discretion.

    **Run Branch (3 nodes, TECH-05):**
    | Node | DisplayName | BaseCost | Tier | Prereqs | Effect |
    |------|-------------|----------|------|---------|--------|
    | run_time_1 | Level Time I | 500 | 1 | [START] | RunDuration +5 |
    | run_time_2 | Level Time II | 900 | 2 | [time_1] | RunDuration +5 |
    | run_time_3 | Level Time III | 1500 | 3 | [time_2] | RunDuration +10 |

    **Progression Branch (4 nodes, TECH-06):**
    | Node | DisplayName | BaseCost | Tier | Prereqs | Effect |
    |------|-------------|----------|------|---------|--------|
    | prog_level_2 | Advance to Level 2 | 3000 | 1 | [START] | AdvanceLevel +1 |
    | prog_level_3 | Advance to Level 3 | 8000 | 1 | [level_2] | AdvanceLevel +1 |
    | prog_level_4 | Advance to Level 4 | 20000 | 1 | [level_3] | AdvanceLevel +1 |
    | prog_level_5 | Advance to Level 5 | 50000 | 1 | [level_4] | AdvanceLevel +1 |

    **How to create assets:** Since this is a code-only project (no manual Unity editor), create the UpgradeNodeSO instances and TechTreeDefinition.asset programmatically:
    - Option A (preferred): In TechTreeController, if no TechTreeSO is assigned, call a static `CreateDefaultTree()` method that builds all node data in code (not as ScriptableObject assets on disk, but as runtime-constructed data). Store node definitions as a static array of node descriptors and construct them at Initialize time. This avoids needing the Unity editor for asset creation. The TechTreeSO reference in UISetup would be null, and TechTreeController falls back to the built-in definitions.
    - Option B: Use an [InitializeOnLoadMethod] editor script to create .asset files. This requires the editor.

    **Use Option A:** Define all node data in a static helper class `TechTreeDefinitions.cs` that returns a runtime TechTreeSO-equivalent data structure. TechTreeController.Initialize can accept either a TechTreeSO asset OR fall back to TechTreeDefinitions.GetDefaultTree(). This keeps the project fully code-driven consistent with the UISetup pattern.

    Create `Assets/Scripts/Data/TechTreeDefinitions.cs`:
    - Static class with `GetAllNodes()` returning an array of node descriptors
    - Each descriptor: NodeId, DisplayName, Description, Branch, BaseCost, TierLevel, PrerequisiteIds (string[]), Effects (StatEffect[]), GraphPosition (Vector2), SkillIndex
    - Graph positions calculated based on branch angle and depth (tier level determines radial distance from center)

    Actually, simpler: TechTreeController can build UpgradeNodeSO instances at runtime using ScriptableObject.CreateInstance<UpgradeNodeSO>() and populate all fields. Prerequisites are resolved after all nodes are created via the nodeIdToIndex dictionary. This keeps the existing SO class useful while enabling fully programmatic construction.
  </action>
  <verify>
    Project compiles without errors. Verify:
    - TechTreeTooltip.cs exists and creates tooltip UI hierarchy
    - All ~40 node definitions exist in TechTreeDefinitions or equivalent
    - AudioManager has purchase SFX method
    - Tooltip shows on hover and hides on exit
    - Node definitions cover all 5 branches matching TECH-02 through TECH-06
  </verify>
  <done>
    Tech tree has hover tooltips showing node details with current-vs-next stat preview. All ~40 upgrade nodes are defined programmatically covering all 5 branches (Mining 11, Economy 8, Ship 13, Run 3, Progression 4). Purchase plays audio feedback. Tooltip positions correctly within screen bounds and updates on hover.
  </done>
</task>

</tasks>

<verification>
1. Tech tree screen appears when entering Upgrading phase (after results screen Continue)
2. START node visible at center, 5 branches radiating outward
3. Nodes adjacent to START are green (affordable) or red (too expensive)
4. Nodes NOT connected to any purchased node are hidden
5. Clicking a green node: credits deduct, node turns blue, adjacent hidden nodes reveal
6. Pan (right-click drag) and zoom (scroll wheel) work correctly
7. Hovering a node shows tooltip with name, cost, effect, stat preview
8. Credit total at top updates after purchases
9. All stat effects apply to correct ECS singletons (verify by starting a run after purchase)
10. Purchasing Laser Burst unlock makes it appear in the skill bar
11. State persists: purchase nodes, close and reopen game, purchased nodes remain blue
</verification>

<success_criteria>
- Tech tree displays between runs with center-outward layout
- All 4 node visual states render correctly (blue/green/red/hidden)
- Purchase flow: click green -> deduct credits -> apply stats -> blue -> reveal neighbors
- Pan/zoom navigation works with New Input System (Mouse.current)
- Tooltip displays on hover with stat preview
- Purchase SFX plays on buy
- All ~40 nodes defined and positioned across 5 branches
- State persists via SaveManager
</success_criteria>

<output>
After completion, create `.planning/phases/06-tech-tree-and-level-progression/06-02-SUMMARY.md`
</output>
