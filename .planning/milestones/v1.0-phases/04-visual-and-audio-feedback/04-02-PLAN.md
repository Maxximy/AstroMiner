---
phase: 04-visual-and-audio-feedback
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - Assets/Scripts/MonoBehaviours/Audio/AudioManager.cs
  - Assets/Scripts/MonoBehaviours/Bridge/FeedbackEventBridge.cs
  - Assets/Scripts/MonoBehaviours/Rendering/CameraShake.cs
  - Assets/Scripts/MonoBehaviours/Rendering/TimerWarningEffect.cs
  - Assets/Scripts/MonoBehaviours/Core/UISetup.cs
  - Assets/Scripts/States/GameOverState.cs
  - Assets/Scripts/Shared/GameConstants.cs
autonomous: false
requirements:
  - FEED-07
  - FEED-08
  - AUDI-01
  - AUDI-02
  - AUDI-03
  - AUDI-04
  - AUDI-05
  - AUDI-06
  - AUDI-07
  - AUDI-08

must_haves:
  truths:
    - "Mining hit SFX plays on each damage tick with volume attenuated by distance from camera center"
    - "Asteroid destruction plays a heavy thud/explosion SFX"
    - "Mineral collection plays a chime SFX with pitch varying by batch size (batched within 50ms window)"
    - "Game over triggers a fanfare audio clip"
    - "Ambient space music loops in the background via a dedicated Music AudioSource"
    - "AudioMixer provides separate SFX and Music volume channels with exposed parameters"
    - "UI button clicks play a click SFX"
    - "Screen shakes briefly (2-3 frames) when a critical damage event occurs"
    - "Red vignette fades in steadily during the last 10 seconds of a run and stays at constant intensity"
    - "FeedbackEventBridge drains all three ECS event buffers each frame and dispatches to visual and audio managers"
  artifacts:
    - path: "Assets/Scripts/MonoBehaviours/Audio/AudioManager.cs"
      provides: "Singleton audio system with AudioSource pool, mixer routing, SFX/music playback"
      contains: "AudioManager"
    - path: "Assets/Scripts/MonoBehaviours/Bridge/FeedbackEventBridge.cs"
      provides: "ECS event buffer drain and dispatch to all feedback managers"
      contains: "FeedbackEventBridge"
    - path: "Assets/Scripts/MonoBehaviours/Rendering/CameraShake.cs"
      provides: "Brief screen shake on critical hits and skill impacts"
      contains: "CameraShake"
    - path: "Assets/Scripts/MonoBehaviours/Rendering/TimerWarningEffect.cs"
      provides: "Red vignette during last 10 seconds of run"
      contains: "TimerWarningEffect"
  key_links:
    - from: "Assets/Scripts/MonoBehaviours/Bridge/FeedbackEventBridge.cs"
      to: "DamagePopupManager, ExplosionManager, AudioManager, CameraShake"
      via: "LateUpdate drains DynamicBuffers and calls manager methods"
      pattern: "DamagePopupManager\\.Instance\\.Spawn"
    - from: "Assets/Scripts/MonoBehaviours/Audio/AudioManager.cs"
      to: "AudioMixer asset"
      via: "SerializeField or runtime FindObjectOfType"
      pattern: "_mixer\\.SetFloat"
    - from: "Assets/Scripts/MonoBehaviours/Rendering/TimerWarningEffect.cs"
      to: "GameStateData.Timer"
      via: "ECS singleton read in Update"
      pattern: "Vignette.*intensity.*Override"
---

<objective>
Build the audio system, screen effects, and the central FeedbackEventBridge that wires all Phase 4 systems together. AudioManager provides pooled AudioSource playback routed through an AudioMixer with separate SFX/Music channels. FeedbackEventBridge drains all three ECS event buffers (DamageEvent, DestructionEvent, CollectionEvent) each frame and dispatches to visual managers (from 04-01) and audio managers. CameraShake and TimerWarningEffect add screen juice. A checkpoint ensures AudioMixer and audio clip assets are created in the Unity Editor.

Purpose: This plan completes Phase 4 by adding audio feedback to every game action and wiring the ECS event pipeline to all consumers. Without this plan, the visual feedback from 04-01 has no audio accompaniment and the event buffers are never drained.
Output: Full feedback pipeline from ECS events through FeedbackEventBridge to DamagePopupManager, ExplosionManager, AudioManager, CameraShake, and TimerWarningEffect.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-visual-and-audio-feedback/04-RESEARCH.md
@.planning/phases/04-visual-and-audio-feedback/04-01-SUMMARY.md

Key existing files:
@Assets/Scripts/ECS/Components/FeedbackComponents.cs (DamageEvent, DestructionEvent from 04-01)
@Assets/Scripts/ECS/Components/MineralComponents.cs (CollectionEvent)
@Assets/Scripts/ECS/Components/GameStateComponents.cs (GameStateData.Timer)
@Assets/Scripts/MonoBehaviours/Rendering/DamagePopupManager.cs (from 04-01)
@Assets/Scripts/MonoBehaviours/Rendering/ExplosionManager.cs (from 04-01)
@Assets/Scripts/MonoBehaviours/Pool/GameObjectPool.cs (reference for pool pattern)
@Assets/Scripts/MonoBehaviours/Core/UISetup.cs (add button click SFX wiring)
@Assets/Scripts/States/GameOverState.cs (add fanfare playback)
@Assets/Scripts/Shared/GameConstants.cs (add audio constants)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AudioManager, CameraShake, TimerWarningEffect, and FeedbackEventBridge</name>
  <files>
    Assets/Scripts/MonoBehaviours/Audio/AudioManager.cs
    Assets/Scripts/MonoBehaviours/Rendering/CameraShake.cs
    Assets/Scripts/MonoBehaviours/Rendering/TimerWarningEffect.cs
    Assets/Scripts/MonoBehaviours/Bridge/FeedbackEventBridge.cs
    Assets/Scripts/MonoBehaviours/Core/UISetup.cs
    Assets/Scripts/States/GameOverState.cs
    Assets/Scripts/Shared/GameConstants.cs
  </files>
  <action>
    **1. Create `Assets/Scripts/MonoBehaviours/Audio/AudioManager.cs`:**

    Create the `Assets/Scripts/MonoBehaviours/Audio/` directory if it does not exist.

    Singleton MonoBehaviour with `public static AudioManager Instance`. Self-instantiates via `[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]` pattern (same as SaveManager, DamagePopupManager).

    **AudioMixer integration:**
    - Private field: `private UnityEngine.Audio.AudioMixer _mixer;`
    - Private field: `private UnityEngine.Audio.AudioMixerGroup _sfxGroup;`
    - Private field: `private UnityEngine.Audio.AudioMixerGroup _musicGroup;`
    - In Start/Awake, attempt to load mixer: `_mixer = Resources.Load<UnityEngine.Audio.AudioMixer>("GameAudioMixer");`
    - If null, log warning but continue (audio plays without mixer routing -- graceful degradation)
    - If found, find groups: `_sfxGroup = _mixer.FindMatchingGroups("SFX")[0]` and `_musicGroup = _mixer.FindMatchingGroups("Music")[0]`

    **AudioSource pool for SFX:**
    - Create 20 child GameObjects each with an AudioSource component
    - All AudioSources: spatialBlend = 0 (2D only -- WebGL spatial blend is broken per research), playOnAwake = false
    - Route all SFX sources to _sfxGroup (if available)
    - Use Queue<AudioSource> for available sources, return when clip finishes via coroutine

    **Music source:**
    - Dedicated AudioSource for music: loop = true, spatialBlend = 0, route to _musicGroup
    - `public void PlayMusic(AudioClip clip)`: assign clip and play. If clip is null, do nothing.
    - `public void StopMusic()`: stop music source

    **SFX playback methods:**

    `public void PlaySFX(AudioClip clip, Vector3 position, float volume = 1f, float pitch = 1f)`:
    - If clip is null or pool empty, return silently
    - Dequeue a source, set clip/volume/pitch
    - Manual distance-based volume attenuation: compute distance from position to Camera.main.transform.position, `float attenuation = Mathf.Clamp01(1f - dist / 30f)`, multiply volume by attenuation
    - Play, start coroutine to return to pool when clip.length finishes (or after a max 3-second timeout)

    **Specialized playback methods:**

    `public void PlayDamageHit(Vector3 position)`:
    - Throttle: max 4 mining hit SFX per second. Track `_lastDamageHitTime`, skip if Time.time - _lastDamageHitTime < 0.25f
    - Call PlaySFX with _damageHitClip, position, volume 0.5f, pitch with slight random variation (0.9-1.1)

    `public void PlayDestruction(Vector3 position)`:
    - Call PlaySFX with _destructionClip, position, volume 0.8f

    `public void PlayGameOverFanfare()`:
    - Call PlaySFX with _fanfareClip, Camera.main.transform.position (centered), volume 1.0f

    `public void PlayUIClick()`:
    - Call PlaySFX with _uiClickClip, Camera.main.transform.position, volume 0.6f

    **Collection chime batching (per Claude's discretion -- batch within 50ms window):**
    - Private fields: `_collectionBatchCount`, `_collectionBatchTimer`, `_collectionBatchTier`
    - `public void QueueCollectionChime(int resourceTier)`: increment _collectionBatchCount, set tier, start 50ms timer if not already running
    - In Update: if _collectionBatchTimer > 0, decrement. When it hits 0 and _collectionBatchCount > 0: play _collectionChimeClip with pitch = 1.0f + 0.05f * Mathf.Min(_collectionBatchCount, 10). Reset batch count.

    **Volume control:**
    - `public void SetSFXVolume(float linearValue)`: convert to dB via `value > 0.001f ? Mathf.Log10(value) * 20f : -80f`, call `_mixer?.SetFloat("SFXVolume", db)`
    - `public void SetMusicVolume(float linearValue)`: same pattern with "MusicVolume"

    **Audio clip references:**
    - Store as private fields: `_damageHitClip`, `_destructionClip`, `_collectionChimeClip`, `_fanfareClip`, `_uiClickClip`, `_musicClip`
    - Load via `Resources.Load<AudioClip>("Audio/SFX/...")` in Start. Use null checks -- clips may not exist yet (graceful degradation)
    - Alternatively use [SerializeField] for inspector wiring -- BUT since we self-instantiate, Resources.Load is more reliable

    **For now, audio clips will be placeholder/null until the checkpoint task creates actual audio assets. All methods handle null clips gracefully (return silently).**

    **2. Create `Assets/Scripts/MonoBehaviours/Rendering/CameraShake.cs`:**

    Singleton MonoBehaviour with `public static CameraShake Instance`. Self-instantiates on the Main Camera (NOT a new GameObject -- must be on the camera). In AutoCreate:
    ```csharp
    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
    private static void AutoCreate()
    {
        if (Instance != null) return;
        var cam = Camera.main;
        if (cam != null)
            Instance = cam.gameObject.AddComponent<CameraShake>();
    }
    ```

    **Fields:**
    - `private Vector3 _originalLocalPos;`
    - `private float _shakeDuration;`
    - `private float _shakeMagnitude = 0.15f;`
    - `private bool _shaking;`

    **Awake:** Cache `_originalLocalPos = transform.localPosition;`

    **Public method `Shake(float duration = 0.05f, float magnitude = 0.15f)`:**
    - Per user decision: light intensity, 2-3 frames = ~0.05s
    - Set `_shakeDuration = duration; _shakeMagnitude = magnitude; _shaking = true;`
    - If already shaking, restart timer but don't increase magnitude (prevent stacking)

    **LateUpdate:**
    ```csharp
    if (_shaking && _shakeDuration > 0)
    {
        // Random offset in XZ plane (camera looks down from Y=18)
        Vector3 offset = new Vector3(
            UnityEngine.Random.Range(-1f, 1f) * _shakeMagnitude,
            0f,
            UnityEngine.Random.Range(-1f, 1f) * _shakeMagnitude
        );
        transform.localPosition = _originalLocalPos + offset;
        _shakeDuration -= Time.deltaTime;
    }
    else if (_shaking)
    {
        transform.localPosition = _originalLocalPos;
        _shaking = false;
    }
    ```

    **3. Create `Assets/Scripts/MonoBehaviours/Rendering/TimerWarningEffect.cs`:**

    MonoBehaviour that self-instantiates. Reads GameStateData.Timer from ECS and controls URP Vignette intensity.

    ```csharp
    using UnityEngine;
    using UnityEngine.Rendering;
    using UnityEngine.Rendering.Universal;
    using Unity.Entities;

    public class TimerWarningEffect : MonoBehaviour
    {
        public static TimerWarningEffect Instance { get; private set; }

        private Volume _volume;
        private Vignette _vignette;
        private EntityManager _em;
        private EntityQuery _gameStateQuery;
        private bool _initialized;

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
        private static void AutoCreate()
        {
            if (Instance == null)
            {
                var go = new GameObject("TimerWarningEffect");
                Instance = go.AddComponent<TimerWarningEffect>();
            }
        }

        void Awake() { Instance = this; }

        void Start()
        {
            // Find or create the Volume component
            _volume = FindAnyObjectByType<Volume>();
            if (_volume != null && _volume.profile != null)
            {
                if (!_volume.profile.TryGet<Vignette>(out _vignette))
                {
                    // Add Vignette override if not present
                    _vignette = _volume.profile.Add<Vignette>(overrideState: true);
                }
            }
        }

        void Update()
        {
            if (_vignette == null) return;

            if (!_initialized)
            {
                var world = World.DefaultGameObjectInjectionWorld;
                if (world == null || !world.IsCreated) return;
                _em = world.EntityManager;
                _gameStateQuery = _em.CreateEntityQuery(typeof(GameStateData));
                _initialized = true;
            }

            if (_gameStateQuery.CalculateEntityCount() == 0) return;
            var gameState = _gameStateQuery.GetSingleton<GameStateData>();

            // Per user decision: steady red vignette that fades in at 10 seconds, stays constant
            if (gameState.Phase == GamePhase.Playing && gameState.Timer <= 10f && gameState.Timer > 0f)
            {
                float t = 1f - (gameState.Timer / 10f); // 0->1 as timer 10->0
                _vignette.color.Override(Color.red);
                _vignette.intensity.Override(Mathf.Lerp(0f, 0.4f, t));
                _vignette.active = true;
            }
            else
            {
                _vignette.intensity.Override(0f);
            }
        }
    }
    ```

    **Note:** The phase 01-01 summary mentions "Vignette disabled in volume profile per clean visual style decision." The TimerWarningEffect re-enables vignette only when timer < 10s and sets intensity to 0 otherwise, so it respects the clean style during normal gameplay.

    **4. Create `Assets/Scripts/MonoBehaviours/Bridge/FeedbackEventBridge.cs`:**

    This is the central dispatcher. Self-instantiates. In LateUpdate, drains all three ECS event buffers and calls the appropriate managers.

    ```csharp
    using UnityEngine;
    using Unity.Entities;
    using Unity.Mathematics;

    public class FeedbackEventBridge : MonoBehaviour
    {
        public static FeedbackEventBridge Instance { get; private set; }

        private EntityManager _em;
        private EntityQuery _damageBufferQuery;
        private EntityQuery _destructionBufferQuery;
        private EntityQuery _collectionBufferQuery;
        private bool _initialized;

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
        private static void AutoCreate()
        {
            if (Instance == null)
            {
                var go = new GameObject("FeedbackEventBridge");
                Instance = go.AddComponent<FeedbackEventBridge>();
            }
        }

        void Awake() { Instance = this; }

        void LateUpdate()
        {
            if (!_initialized)
            {
                var world = World.DefaultGameObjectInjectionWorld;
                if (world == null || !world.IsCreated) return;
                _em = world.EntityManager;

                _damageBufferQuery = _em.CreateEntityQuery(typeof(DamageEvent));
                _destructionBufferQuery = _em.CreateEntityQuery(typeof(DestructionEvent));
                _collectionBufferQuery = _em.CreateEntityQuery(typeof(CollectionEvent));
                _initialized = true;
            }

            DrainDamageEvents();
            DrainDestructionEvents();
            DrainCollectionEvents();
        }

        private void DrainDamageEvents()
        {
            if (_damageBufferQuery.CalculateEntityCount() == 0) return;
            var entity = _damageBufferQuery.GetSingletonEntity();
            var buffer = _em.GetBuffer<DamageEvent>(entity);

            for (int i = 0; i < buffer.Length; i++)
            {
                var evt = buffer[i];
                var pos = new Vector3(evt.Position.x, evt.Position.y, evt.Position.z);

                // Visual: damage popup
                DamagePopupManager.Instance?.Spawn(evt.Position, evt.Amount, evt.Type, evt.ColorR, evt.ColorG, evt.ColorB);

                // Audio: mining hit SFX
                AudioManager.Instance?.PlayDamageHit(pos);

                // Screen shake on critical hits (Phase 5 will produce these)
                if (evt.Type == DamageType.Critical)
                {
                    CameraShake.Instance?.Shake();
                }
            }
            buffer.Clear();
        }

        private void DrainDestructionEvents()
        {
            if (_destructionBufferQuery.CalculateEntityCount() == 0) return;
            var entity = _destructionBufferQuery.GetSingletonEntity();
            var buffer = _em.GetBuffer<DestructionEvent>(entity);

            for (int i = 0; i < buffer.Length; i++)
            {
                var evt = buffer[i];
                var pos = new Vector3(evt.Position.x, evt.Position.y, evt.Position.z);

                // Visual: explosion particles
                ExplosionManager.Instance?.PlayExplosion(evt.Position, evt.Scale);

                // Audio: destruction SFX
                AudioManager.Instance?.PlayDestruction(pos);
            }
            buffer.Clear();
        }

        private void DrainCollectionEvents()
        {
            if (_collectionBufferQuery.CalculateEntityCount() == 0) return;
            var entity = _collectionBufferQuery.GetSingletonEntity();
            var buffer = _em.GetBuffer<CollectionEvent>(entity);

            for (int i = 0; i < buffer.Length; i++)
            {
                var evt = buffer[i];

                // Audio: collection chime (batched)
                AudioManager.Instance?.QueueCollectionChime(evt.ResourceTier);
            }
            buffer.Clear();
        }
    }
    ```

    **5. Modify `UISetup.cs` -- Wire UI button click SFX (AUDI-07):**

    In `CreateButton` method, after `button.targetGraphic = buttonImage;`, add a click listener:
    ```csharp
    button.onClick.AddListener(() => AudioManager.Instance?.PlayUIClick());
    ```

    This wires ALL buttons created by UISetup (Continue, Start Run) with click SFX automatically.

    **6. Modify `GameOverState.cs` -- Add game over fanfare (AUDI-05):**

    In `Enter(GameManager manager)`, after `SaveManager.Instance?.AutoSave();`, add:
    ```csharp
    AudioManager.Instance?.PlayGameOverFanfare();
    ```

    **7. Add audio constants to `GameConstants.cs`:**

    ```csharp
    // -- Audio Defaults ------------------------------------------------

    /// <summary>Maximum simultaneous SFX AudioSources.</summary>
    public const int AudioSFXPoolSize = 20;

    /// <summary>Minimum interval between mining hit SFX plays (seconds).</summary>
    public const float DamageHitSFXCooldown = 0.25f;

    /// <summary>Collection chime batch window (seconds).</summary>
    public const float CollectionChimeBatchWindow = 0.05f;

    /// <summary>Max distance for SFX volume attenuation.</summary>
    public const float SFXMaxDistance = 30f;

    /// <summary>Screen shake duration (seconds, ~3 frames at 60fps).</summary>
    public const float ScreenShakeDuration = 0.05f;

    /// <summary>Screen shake magnitude (world units offset).</summary>
    public const float ScreenShakeMagnitude = 0.15f;

    /// <summary>Timer warning vignette trigger threshold (seconds remaining).</summary>
    public const float TimerWarningThreshold = 10f;

    /// <summary>Timer warning vignette max intensity.</summary>
    public const float TimerWarningMaxIntensity = 0.4f;
    ```

    **8. Music playback:**

    AudioManager should attempt to start background music in Start (after a short delay to ensure WebGL user interaction has occurred -- gate on first frame with valid input, or just start it and accept it may be silent until first click on WebGL). Add a simple `StartMusicIfReady` check in Update that starts music once after first frame:
    ```csharp
    private bool _musicStarted;
    void Update()
    {
        // ... collection chime batching logic ...

        if (!_musicStarted && _musicClip != null)
        {
            PlayMusic(_musicClip);
            _musicStarted = true;
        }
    }
    ```

    **AUDI-04 (Skill activation SFX):** Create a stub method `public void PlaySkillSFX(int skillType)` that does nothing for now. Phase 5 will implement real skill sounds. This ensures the API exists for Phase 5 to call.
  </action>
  <verify>
    Open Unity Editor. Check Console for compilation errors. All new scripts must compile.
    Enter Play mode:
    1. FeedbackEventBridge should log or visibly drain events (damage popups still appear, explosions still play from 04-01)
    2. CameraShake component should be visible on Main Camera in Inspector
    3. TimerWarningEffect should show red vignette when timer drops below 10 seconds
    4. AudioManager should exist in hierarchy (may have null clips -- that is expected until checkpoint task)
    5. Clicking UI buttons should not cause errors (AudioManager handles null clips gracefully)
  </verify>
  <done>
    AudioManager singleton exists with SFX pool, mixer integration, and all playback methods. FeedbackEventBridge drains DamageEvent/DestructionEvent/CollectionEvent buffers every frame and dispatches to DamagePopupManager, ExplosionManager, AudioManager, and CameraShake. CameraShake applies brief random offset on critical hit events. TimerWarningEffect reads GameStateData.Timer and fades in red URP Vignette during last 10 seconds. UISetup buttons have click SFX listeners. GameOverState triggers fanfare. Collection chimes batch within 50ms window. All scripts compile without errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Create AudioMixer asset, source audio clips, and verify full feedback pipeline</name>
  <files>
    Assets/Resources/GameAudioMixer.mixer
    Assets/Resources/Audio/SFX/DamageHit.wav
    Assets/Resources/Audio/SFX/Destruction.wav
    Assets/Resources/Audio/SFX/CollectionChime.wav
    Assets/Resources/Audio/SFX/UIClick.wav
    Assets/Resources/Audio/SFX/Fanfare.wav
    Assets/Resources/Audio/Music/AmbientSpace.ogg
  </files>
  <action>
    The complete Phase 4 feedback pipeline is coded but audio clips are placeholder/null. The AudioManager loads clips from `Resources/Audio/SFX/` and `Resources/Audio/Music/` paths, and the AudioMixer from `Resources/GameAudioMixer`. These assets must be created in the Unity Editor because AudioMixer assets cannot be created at runtime and audio clips must be sourced from external royalty-free libraries.

    **Step 1: Create AudioMixer asset**
    In Unity Editor: Assets menu > Create > Audio Mixer. Name it `GameAudioMixer`.
    Save it to `Assets/Resources/GameAudioMixer.mixer`.
    In the AudioMixer window:
    - The Master group already exists
    - Add child group "SFX" under Master
    - Add child group "Music" under Master
    - Right-click the SFX group volume slider > Expose parameter, name it "SFXVolume"
    - Right-click the Music group volume slider > Expose parameter, name it "MusicVolume"
    - Set Music group volume to -6 dB (quieter than SFX by default)

    **Step 2: Source and import audio clips**
    Download free CC0/royalty-free audio clips (suggested sources: freesound.org, opengameart.org, sonniss.com/gameaudiogdc, mixkit.co):
    - Mining hit sound (short metallic impact/thud, ~0.2s): save as `Assets/Resources/Audio/SFX/DamageHit.wav`
    - Destruction explosion (heavy crunch/shatter, ~0.5s): save as `Assets/Resources/Audio/SFX/Destruction.wav`
    - Collection chime (bright electronic blip, ~0.3s): save as `Assets/Resources/Audio/SFX/CollectionChime.wav`
    - UI click (soft electronic click, ~0.1s): save as `Assets/Resources/Audio/SFX/UIClick.wav`
    - Game over fanfare (short triumphant jingle, ~2s): save as `Assets/Resources/Audio/SFX/Fanfare.wav`
    - Space ambient music loop (chill synth, 2-4 minutes): save as `Assets/Resources/Audio/Music/AmbientSpace.ogg`

    The file names must match exactly (AudioManager.cs loads these by path via Resources.Load).
  </action>
  <verify>
    Enter Play mode and verify the full feedback pipeline:
    1. Mining hit sound plays when mining circle overlaps asteroids (throttled to ~4/sec)
    2. Destruction sound plays when asteroid HP reaches 0
    3. Collection chime plays when minerals reach ship (batched, pitch increases with rapid collection)
    4. UI button clicks produce a click sound
    5. Ambient music loops in background
    6. Game over fanfare plays when run timer expires
    7. Red vignette appears during last 10 seconds of run
    8. Damage numbers still appear and float correctly
    9. Explosion particles still appear on asteroid destruction
    10. Mineral trails still visible during flight
    11. Credit counter still pops on credit change
    Type "approved" if all feedback systems work, or describe any issues.
  </verify>
  <done>
    AudioMixer asset exists with Master > SFX + Music groups and exposed SFXVolume/MusicVolume parameters. All six audio clips imported and loading correctly via Resources.Load. Full feedback pipeline verified: damage popups + hit SFX on mining ticks, explosion particles + destruction SFX on asteroid kills, mineral trails + collection chimes on pickup, UI click SFX on buttons, game over fanfare, ambient music loop, red vignette timer warning, credit counter pop animation.
  </done>
</task>

</tasks>

<verification>
1. Full pipeline test: mine asteroids until destruction -- damage numbers + hit SFX on each tick, explosion particles + destruction SFX on kill, mineral trails + collection chimes on pickup
2. Timer warning: let timer run below 10 seconds -- red vignette fades in steadily
3. Game over: timer expires -- fanfare plays, results screen shows
4. UI: click Continue and Start Run buttons -- click SFX plays
5. Music: ambient loop plays continuously in background
6. Volume: AudioMixer has separate SFX and Music controls (verify in AudioMixer window)
7. Performance: 50+ asteroids with feedback active, no visible frame drops
8. WebGL: spatial blend is 0 on all AudioSources (verify in Inspector)
</verification>

<success_criteria>
- FeedbackEventBridge drains all three event buffers every frame and dispatches to 5 consumer systems
- AudioManager plays SFX for damage hits, destruction, collection, UI clicks, and game over fanfare
- Background music loops via dedicated Music AudioSource
- AudioMixer has Master > SFX + Music groups with exposed volume parameters
- CameraShake applies brief offset on DamageType.Critical events (ready for Phase 5)
- TimerWarningEffect shows red vignette in last 10 seconds
- Mining hit SFX throttled to max 4/sec, collection chimes batched within 50ms window
- All AudioSources use spatialBlend = 0 with manual distance-based volume attenuation
- All files compile, no runtime errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-visual-and-audio-feedback/04-02-SUMMARY.md`
</output>
