---
phase: 04-visual-and-audio-feedback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Assets/Scripts/ECS/Components/FeedbackComponents.cs
  - Assets/Scripts/ECS/Systems/MiningDamageSystem.cs
  - Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs
  - Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs
  - Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
  - Assets/Scripts/Shared/GameConstants.cs
  - Assets/Scripts/MonoBehaviours/Rendering/DamagePopupManager.cs
  - Assets/Scripts/MonoBehaviours/Rendering/ExplosionManager.cs
  - Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs
  - Assets/Scripts/MonoBehaviours/Core/AsteroidRenderer.cs
  - Assets/Scripts/MonoBehaviours/UI/HUDController.cs
autonomous: true
requirements:
  - FEED-01
  - FEED-02
  - FEED-03
  - FEED-04
  - FEED-05
  - FEED-06
  - VISL-03
  - VISL-04

must_haves:
  truths:
    - "Floating white damage numbers appear at each asteroid's position on every damage tick, float upward, and fade out over ~1 second"
    - "Damage numbers support four visual styles via DamageType enum: white normal, yellow 'CRIT!' with scale boost, orange italic DoT, and skill-colored medium (infrastructure ready for Phase 5 events)"
    - "Asteroid destruction spawns chunky debris particle explosion at the asteroid's last position"
    - "Minerals leave a color-matched glowing trail as they fly toward the ship"
    - "Asteroids have distinct per-resource-tier color palettes via MaterialPropertyBlock"
    - "Rare minerals glow with HDR emissive color via MaterialPropertyBlock"
    - "Credit counter in HUD briefly scales up and flashes gold when credits change"
  artifacts:
    - path: "Assets/Scripts/ECS/Components/FeedbackComponents.cs"
      provides: "DamageEvent, DestructionEvent IBufferElementData structs and DamageType enum"
      contains: "DamageType"
    - path: "Assets/Scripts/MonoBehaviours/Rendering/DamagePopupManager.cs"
      provides: "Pooled world-space TMPro damage popup system"
      contains: "DamagePopupManager"
    - path: "Assets/Scripts/MonoBehaviours/Rendering/ExplosionManager.cs"
      provides: "Pooled ParticleSystem asteroid explosion effects"
      contains: "ExplosionManager"
  key_links:
    - from: "Assets/Scripts/ECS/Systems/MiningDamageSystem.cs"
      to: "DamageEvent buffer"
      via: "SystemAPI.GetSingletonBuffer<DamageEvent>()"
      pattern: "damageBuffer\\.Add"
    - from: "Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs"
      to: "DestructionEvent buffer"
      via: "SystemAPI.GetSingletonBuffer<DestructionEvent>()"
      pattern: "destructionBuffer\\.Add"
    - from: "Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs"
      to: "CollectionEvent buffer"
      via: "SystemAPI.GetSingletonBuffer<CollectionEvent>()"
      pattern: "collectionBuffer\\.Add"
---

<objective>
Build the ECS-to-MonoBehaviour event pipeline and all visual feedback systems. ECS systems emit DamageEvent, DestructionEvent, and CollectionEvent buffers on every damage tick, asteroid kill, and mineral collection. Visual feedback managers (DamagePopupManager, ExplosionManager) consume these events to spawn pooled world-space damage numbers and chunky debris explosions. Mineral trails and material improvements complete the visual polish.

Purpose: This plan creates the backbone event pipeline that Phase 4 Plan 02 (audio) also depends on, plus all visual feedback that makes mining feel impactful.
Output: DamageEvent/DestructionEvent/CollectionEvent buffers populated by ECS systems; DamagePopupManager, ExplosionManager, TrailRenderer on minerals, improved materials, credit counter pop animation.
</objective>

<execution_context>
@C:/Users/max/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-visual-and-audio-feedback/04-RESEARCH.md

Key existing files to read before implementing:
@Assets/Scripts/ECS/Components/MineralComponents.cs (CollectionEvent already defined here)
@Assets/Scripts/ECS/Components/AsteroidComponents.cs (HealthData, DamageTickTimer, MiningConfigData)
@Assets/Scripts/ECS/Components/GameStateComponents.cs (GameStateData, InputData)
@Assets/Scripts/ECS/Systems/MiningDamageSystem.cs (must emit DamageEvents)
@Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs (must emit DestructionEvents)
@Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs (must emit CollectionEvents)
@Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs (must create DamageEvent/DestructionEvent buffer entities)
@Assets/Scripts/MonoBehaviours/Pool/GameObjectPool.cs (reuse for popup and explosion pools)
@Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs (add TrailRenderer, HDR emissive)
@Assets/Scripts/MonoBehaviours/Core/AsteroidRenderer.cs (add per-tier MaterialPropertyBlock colors)
@Assets/Scripts/MonoBehaviours/UI/HUDController.cs (add credit counter pop animation)
@Assets/Scripts/Shared/GameConstants.cs (add feedback tuning constants)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ECS event components and modify systems to emit events</name>
  <files>
    Assets/Scripts/ECS/Components/FeedbackComponents.cs
    Assets/Scripts/ECS/Systems/MiningDamageSystem.cs
    Assets/Scripts/ECS/Systems/MineralSpawnSystem.cs
    Assets/Scripts/ECS/Systems/MineralCollectionSystem.cs
    Assets/Scripts/MonoBehaviours/Core/ECSBootstrap.cs
    Assets/Scripts/Shared/GameConstants.cs
  </files>
  <action>
    **1. Create `Assets/Scripts/ECS/Components/FeedbackComponents.cs`:**

    Define three items (CollectionEvent already exists in MineralComponents.cs -- do NOT duplicate it):

    ```csharp
    public enum DamageType : byte { Normal = 0, Critical = 1, DoT = 2, Skill = 3 }

    public struct DamageEvent : IBufferElementData
    {
        public float3 Position;   // world position of damaged asteroid
        public float Amount;      // damage dealt this tick
        public DamageType Type;   // Normal for now, Phase 5 adds crit/DoT/skill
        public byte ColorR, ColorG, ColorB;  // skill color (Burst-safe, no managed Color)
    }

    public struct DestructionEvent : IBufferElementData
    {
        public float3 Position;   // where asteroid died
        public float Scale;       // asteroid visual scale for particle count scaling
        public int ResourceTier;  // for future tier-specific explosion colors
    }
    ```

    Required usings: `Unity.Entities`, `Unity.Mathematics`. All fields unmanaged for Burst compatibility.

    **2. Modify `MiningDamageSystem.cs`:**

    At the top of OnUpdate (after the guard clauses but before the foreach loop), get the DamageEvent buffer:
    ```csharp
    var damageBuffer = SystemAPI.GetSingletonBuffer<DamageEvent>();
    ```

    Inside the `if (tickTimer.ValueRO.Elapsed >= config.TickInterval)` block, after `health.ValueRW.CurrentHP -= config.DamagePerTick;` and before the elapsed subtraction, add:
    ```csharp
    damageBuffer.Add(new DamageEvent
    {
        Position = transform.ValueRO.Position,
        Amount = config.DamagePerTick,
        Type = DamageType.Normal,
        ColorR = 255, ColorG = 255, ColorB = 255
    });
    ```

    Add `using Unity.Mathematics;` if not already present. This stays Burst-compatible because DamageEvent is unmanaged and DynamicBuffer is Burst-safe.

    **3. Modify `MineralSpawnSystem.cs`:**

    At the top of OnUpdate (after guard clauses), get the DestructionEvent buffer:
    ```csharp
    var destructionBuffer = SystemAPI.GetSingletonBuffer<DestructionEvent>();
    ```

    Inside the `if (health.ValueRO.CurrentHP <= 0f)` block, after `ecb.AddComponent<MineralsSpawnedTag>(entity);` and before the mineral spawn loop, add:
    ```csharp
    destructionBuffer.Add(new DestructionEvent
    {
        Position = asteroidPos,
        Scale = 1.0f,  // default scale; future: read from entity component
        ResourceTier = 0
    });
    ```

    **4. Modify `MineralCollectionSystem.cs`:**

    At the top of OnUpdate (after guard clauses), get the CollectionEvent buffer:
    ```csharp
    var collectionBuffer = SystemAPI.GetSingletonBuffer<CollectionEvent>();
    ```

    Inside the `if (dist <= GameConstants.MineralCollectionRadius)` block, after `gameStateRW.ValueRW.Credits += mineralData.ValueRO.CreditValue;` and before `ecb.DestroyEntity(entity);`, add:
    ```csharp
    collectionBuffer.Add(new CollectionEvent
    {
        ResourceTier = mineralData.ValueRO.ResourceTier,
        CreditValue = mineralData.ValueRO.CreditValue,
        Position = transform.ValueRO.Position
    });
    ```

    **5. Update `ECSBootstrap.cs`:**

    Add two new buffer entity creations after the existing CollectionEvent buffer creation:
    ```csharp
    // Create DamageEvent buffer entity (Phase 4 visual/audio feedback)
    var damageEventEntity = em.CreateEntity();
    em.AddBuffer<DamageEvent>(damageEventEntity);

    // Create DestructionEvent buffer entity (Phase 4 explosion/audio feedback)
    var destructionEventEntity = em.CreateEntity();
    em.AddBuffer<DestructionEvent>(destructionEventEntity);
    ```

    Update the Debug.Log to include DamageEventBuffer and DestructionEventBuffer.

    **6. Add feedback constants to `GameConstants.cs`:**

    Add a new section at the bottom:
    ```csharp
    // -- Feedback / VFX Defaults ----------------------------------------

    /// <summary>Duration of damage popup float-up animation (seconds).</summary>
    public const float DamagePopupDuration = 0.8f;

    /// <summary>Speed at which damage popups rise (world units/sec).</summary>
    public const float DamagePopupRiseSpeed = 1.5f;

    /// <summary>Time before popup starts fading (seconds).</summary>
    public const float DamagePopupFadeDelay = 0.3f;

    /// <summary>Font size for normal damage numbers (world-space units).</summary>
    public const float DamagePopupFontSizeNormal = 3f;

    /// <summary>Font size for critical hit numbers (world-space units).</summary>
    public const float DamagePopupFontSizeCrit = 5f;

    /// <summary>Scale multiplier for critical hit popup.</summary>
    public const float DamagePopupCritScale = 1.5f;

    /// <summary>Number of debris particles per asteroid explosion.</summary>
    public const int ExplosionParticleCount = 20;

    /// <summary>Lifetime of debris particles (seconds).</summary>
    public const float ExplosionParticleLifetime = 0.7f;

    /// <summary>Outward velocity of debris particles (units/sec).</summary>
    public const float ExplosionParticleSpeed = 4f;

    /// <summary>Gravity applied to debris particles (units/sec^2).</summary>
    public const float ExplosionParticleGravity = 2.5f;

    /// <summary>Trail duration for mineral flight trails (seconds).</summary>
    public const float MineralTrailDuration = 0.3f;

    /// <summary>Trail start width for mineral flight trails.</summary>
    public const float MineralTrailStartWidth = 0.15f;

    /// <summary>HDR intensity multiplier for mineral glow.</summary>
    public const float MineralEmissiveIntensity = 2f;

    /// <summary>Duration of credit counter pop animation (seconds).</summary>
    public const float CreditPopDuration = 0.2f;

    /// <summary>Scale boost factor for credit counter pop.</summary>
    public const float CreditPopScale = 1.3f;
    ```
  </action>
  <verify>
    Open the project in Unity Editor. Check the Console for compilation errors. All three modified systems (MiningDamageSystem, MineralSpawnSystem, MineralCollectionSystem) must compile without errors. FeedbackComponents.cs must define DamageType, DamageEvent, and DestructionEvent. ECSBootstrap must create three buffer entities (DamageEvent, DestructionEvent, CollectionEvent).
  </verify>
  <done>
    DamageEvent and DestructionEvent IBufferElementData structs exist. DamageType enum has Normal/Critical/DoT/Skill values. MiningDamageSystem appends a DamageEvent on every damage tick. MineralSpawnSystem appends a DestructionEvent when an asteroid reaches 0 HP. MineralCollectionSystem appends a CollectionEvent when a mineral is collected. ECSBootstrap creates singleton buffer entities for all three event types. GameConstants has all feedback tuning values. All files compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create visual feedback managers (popups, explosions, trails, materials, credit pop)</name>
  <files>
    Assets/Scripts/MonoBehaviours/Rendering/DamagePopupManager.cs
    Assets/Scripts/MonoBehaviours/Rendering/ExplosionManager.cs
    Assets/Scripts/MonoBehaviours/Rendering/MineralRenderer.cs
    Assets/Scripts/MonoBehaviours/Core/AsteroidRenderer.cs
    Assets/Scripts/MonoBehaviours/UI/HUDController.cs
  </files>
  <action>
    **1. Create `Assets/Scripts/MonoBehaviours/Rendering/DamagePopupManager.cs`:**

    Singleton MonoBehaviour with public static Instance property. Self-initializes in scene (added to scene by UISetup or GameManager -- see wiring note at bottom).

    **Pool setup (in Start or coroutine after one frame):**
    - Create a popup prefab programmatically: a GameObject with a small world-space Canvas (RenderMode.WorldSpace), a CanvasGroup, and a single TextMeshProUGUI child
    - Canvas size: 2x1 world units, worldCamera = Camera.main
    - TMPro text: fontSize ~3 world units, alignment center, no word wrap
    - Create a GameObjectPool with prefab, pre-warm 100, max 300

    **Spawn method `public void Spawn(float3 position, float amount, DamageType type, byte colorR, byte colorG, byte colorB)`:**
    - Get popup from pool
    - Position at `new Vector3(position.x, 0.5f, position.z)` (slightly above XZ plane)
    - Set text: `Mathf.RoundToInt(amount).ToString()` for normal/DoT/skill, `"CRIT!\n" + Mathf.RoundToInt(amount)` for critical
    - Set color by DamageType: Normal = white, Critical = yellow (1, 0.9, 0.2), DoT = orange (1, 0.6, 0.1), Skill = Color from RGB bytes
    - Set fontStyle: DoT = FontStyles.Italic, others = FontStyles.Normal
    - Set scale: Critical = Vector3.one * GameConstants.DamagePopupCritScale, others = Vector3.one
    - Reset CanvasGroup.alpha to 1
    - Add to active popups list as an ActivePopup struct

    **Update loop (in Update):**
    - Iterate active popups backward (for safe removal)
    - Increment elapsed time by Time.deltaTime
    - Rise: translate position Y += GameConstants.DamagePopupRiseSpeed * Time.deltaTime
    - Compute `t = elapsed / GameConstants.DamagePopupDuration`
    - Fade: if elapsed > GameConstants.DamagePopupFadeDelay, compute fade t and set CanvasGroup.alpha = Lerp(1, 0, fadeT)
    - Billboard: each frame set `popup.transform.rotation = Camera.main.transform.rotation` so popups face camera
    - When t >= 1, release to pool and remove from list
    - Use struct list (not class list) for ActivePopup to minimize GC

    **ActivePopup struct:** GameObject GO, TextMeshProUGUI Text, CanvasGroup Group, float Elapsed

    **Per user decision:** Show every number, no aggregation. Small & subtle size. Every tick produces a popup.

    **2. Create `Assets/Scripts/MonoBehaviours/Rendering/ExplosionManager.cs`:**

    Singleton MonoBehaviour with public static Instance property.

    **Pool setup (in Start or coroutine):**
    - Create explosion prefab programmatically: GameObject with ParticleSystem configured for chunky debris
    - ParticleSystem config (per user decision -- chunky, weighty feel):
      - main.startLifetime = GameConstants.ExplosionParticleLifetime (0.7s)
      - main.startSpeed = GameConstants.ExplosionParticleSpeed (4 units/sec)
      - main.startSize = random between 0.1 and 0.3
      - main.startColor = random between brown (0.55, 0.41, 0.08) and gray (0.4, 0.4, 0.4)
      - main.gravityModifier = GameConstants.ExplosionParticleGravity (2.5)
      - main.simulationSpace = ParticleSystemSimulationSpace.World
      - main.playOnAwake = false
      - main.loop = false
      - main.maxParticles = 30
      - emission: burst of GameConstants.ExplosionParticleCount (20) at time 0
      - shape: sphere, radius 0.3
      - sizeOverLifetime: curve from 1.0 to 0.0 (shrink to nothing)
      - renderer: use default particle material (or URP/Particles/Unlit)
    - Pool: pre-warm 10, max 25 (bounded by asteroid kill rate)
    - Set prefab inactive after configuration

    **Play method `public void PlayExplosion(float3 position, float scale)`:**
    - Get from pool
    - Position at `new Vector3(position.x, 0.1f, position.z)`
    - Optionally scale particle count or size by asteroid scale parameter
    - Call particleSystem.Play()
    - Start coroutine to check particleSystem.IsAlive() and return to pool when done

    **3. Modify `MineralRenderer.cs` -- Add TrailRenderer (FEED-06) and HDR emissive (VISL-04):**

    In `ConfigureMineralVisual(GameObject go)`:
    - After the existing MaterialPropertyBlock color setup, add HDR emissive color:
      ```csharp
      Color hdrColor = DefaultMineralColor * GameConstants.MineralEmissiveIntensity;
      block.SetColor("_EmissionColor", hdrColor);
      ```
    - Enable emission keyword on the material: `renderer.material.EnableKeyword("_EMISSION");`

    - Add TrailRenderer setup:
      ```csharp
      var trail = go.GetComponent<TrailRenderer>();
      if (trail == null) trail = go.AddComponent<TrailRenderer>();
      trail.time = GameConstants.MineralTrailDuration;
      trail.startWidth = GameConstants.MineralTrailStartWidth;
      trail.endWidth = 0f;
      trail.minVertexDistance = 0.1f;
      trail.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
      trail.receiveShadows = false;
      // HDR emissive trail material matching mineral color
      var trailMat = new Material(Shader.Find("Universal Render Pipeline/Unlit"));
      Color trailColor = DefaultMineralColor * GameConstants.MineralEmissiveIntensity;
      trailMat.SetColor("_BaseColor", trailColor);
      trail.material = trailMat;
      ```

    - IMPORTANT: When a mineral GO is returned to pool (released), clear the trail to prevent ghost trails on reuse. In `LateUpdate` cleanup section, before calling `_mineralPool.Release(kvp.Value)`, add: `var trail = kvp.Value.GetComponent<TrailRenderer>(); if (trail != null) trail.Clear();`

    **4. Modify `AsteroidRenderer.cs` -- Per-resource-tier PBR materials (VISL-03):**

    Expand the `AsteroidColors` array to include more distinct per-tier palettes. For now (only tier 0 Iron), keep existing colors but add HDR emissive hint for visual variety. In `ConfigureAsteroidVisual`, after the existing color setup:
    ```csharp
    // Add subtle emissive tint for visual richness
    Color emissive = AsteroidColors[_rng.NextInt(AsteroidColors.Length)] * 0.3f;
    block.SetColor("_EmissionColor", emissive);
    renderer.material.EnableKeyword("_EMISSION");
    renderer.SetPropertyBlock(block);
    ```

    **5. Modify `HUDController.cs` -- Credit counter pop animation (per user decision: scale up + gold flash):**

    Add private fields:
    ```csharp
    private long _previousCredits;
    private float _popTimer;
    private Vector3 _creditsOriginalScale = Vector3.one;
    private Color _creditsOriginalColor = Color.white;
    ```

    In LateUpdate, AFTER the credits text update (`_creditsText.text = ...`), add pop detection and animation:
    ```csharp
    // Detect credit change and trigger pop
    if (gameState.Credits != _previousCredits && _previousCredits != 0)
    {
        _popTimer = GameConstants.CreditPopDuration;
    }
    _previousCredits = gameState.Credits;

    // Animate credit counter pop
    if (_popTimer > 0)
    {
        _popTimer -= Time.deltaTime;
        float t = Mathf.Clamp01(_popTimer / GameConstants.CreditPopDuration);
        float scale = 1f + (GameConstants.CreditPopScale - 1f) * Mathf.Sin(t * Mathf.PI);
        _creditsText.transform.localScale = _creditsOriginalScale * scale;
        _creditsText.color = Color.Lerp(_creditsOriginalColor, new Color(1f, 0.9f, 0.3f), t);
    }
    else
    {
        _creditsText.transform.localScale = _creditsOriginalScale;
        _creditsText.color = _creditsOriginalColor;
    }
    ```

    **Scene wiring note:** DamagePopupManager and ExplosionManager are singletons. They should self-instantiate similar to SaveManager pattern (using `[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]`) OR be added as components on the existing GameManager/Rendering hierarchy. Choose the self-instantiation pattern for consistency:
    ```csharp
    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
    private static void AutoCreate()
    {
        if (Instance == null)
        {
            var go = new GameObject("DamagePopupManager");
            Instance = go.AddComponent<DamagePopupManager>();
        }
    }
    ```
    Same pattern for ExplosionManager.
  </action>
  <verify>
    Open Unity Editor. Check Console for compilation errors. Enter Play mode. Mine asteroids with the mining circle. Verify:
    1. White damage numbers appear at each damaged asteroid's position on every tick (every 0.25 seconds per asteroid in circle)
    2. Numbers float upward and fade out over ~0.8 seconds
    3. When an asteroid is destroyed, a burst of debris particles explodes outward at its position
    4. Minerals have visible glowing trails as they fly toward the ship
    5. Credit counter in HUD briefly scales up when credits change
    6. No errors in Console, no visible performance degradation
  </verify>
  <done>
    DamagePopupManager spawns pooled world-space TMPro popups on every damage tick with correct colors and styles for each DamageType. ExplosionManager spawns pooled ParticleSystem debris explosions on asteroid destruction. MineralRenderer adds TrailRenderer with HDR emissive material for mineral flight trails. AsteroidRenderer has per-tier emissive color variation. HUDController credit counter pops with scale-up and gold flash on credit change. All managers self-instantiate without manual scene setup. No compilation errors.
  </done>
</task>

</tasks>

<verification>
1. Play mode: mine asteroids until they are destroyed -- white damage numbers float up from each asteroid on every 0.25s tick
2. Asteroid destruction produces chunky debris particle explosion at the death position
3. Minerals spawned from destruction have visible glowing trails as they fly to the ship
4. Credit counter at top-right scales up and flashes gold each time minerals are collected
5. Console shows no errors, frame rate stays above 50 FPS with 20+ asteroids and 100+ minerals
6. DamageEvent, DestructionEvent, CollectionEvent buffers are populated by ECS systems (visible via ECS debugger or debug logging)
</verification>

<success_criteria>
- DamageEvent/DestructionEvent buffers exist as ECS singleton buffer entities alongside existing CollectionEvent
- All three ECS systems (MiningDamage, MineralSpawn, MineralCollection) emit events into their respective buffers
- DamagePopupManager pool handles 200+ simultaneous popups without frame drops
- ExplosionManager pool handles concurrent asteroid destructions without frame drops
- Mineral flight trails are visible and color-matched
- Credit counter pop animation is visible on credit change
- All files compile without errors in Unity Editor
</success_criteria>

<output>
After completion, create `.planning/phases/04-visual-and-audio-feedback/04-01-SUMMARY.md`
</output>
